<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[馨木]]></title>
    <link>http://yaxin-cn.github.io/</link>
    <atom:link href="/rss.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[为梦想添砖加瓦]]></description>
    <pubDate>Tue, 26 Jan 2016 10:13:57 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[docker动态映射运行的container端口]]></title>
      <link>http://yaxin-cn.github.io/Linux/expose-port-of-running-docker-container.html</link>
      <guid>http://yaxin-cn.github.io/Linux/expose-port-of-running-docker-container.html</guid>
      <pubDate>Tue, 26 Jan 2016 09:12:03 GMT</pubDate>
      <description>
      <![CDATA[<p>docker自带了<code>EXPOSE</code>命令，可以通过编写<code>dockerfile</code>加<code>-p</code>参数方便的映射container内部端口，但是对于已经运行的container，如果你想对外开放一个新的端口，只能编辑<c]]>
      </description>
      <content:encoded><![CDATA[<p>docker自带了<code>EXPOSE</code>命令，可以通过编写<code>dockerfile</code>加<code>-p</code>参数方便的映射container内部端口，但是对于已经运行的container，如果你想对外开放一个新的端口，只能编辑<code>dockerfile</code>然后重新build，有点不太方便。</p>
<p>其实docker本身使用了<code>iptables</code>来做端口映射的，所以我们可以通过一些简单的操作来实现动态映射运行中的container端口。</p>
<p>通过运行<code>iptables</code>命令可以看到具体的端口映射(下面的实例中IP为192.168.42.41的container开放了22和20280等端口)</p>
<pre><code class="language-shell">[yaxin@ubox ~]$sudo iptables -nvxL
Chain INPUT (policy ACCEPT 262 packets, 529689 bytes)
    pkts      bytes target     prot opt in     out     source               destination
   14355   789552 DROP       tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:25

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
    pkts      bytes target     prot opt in     out     source               destination
 5479459 653248187 DOCKER     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0
   93990 314970368 ACCEPT     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED
 4705395 2183219154 ACCEPT     all  --  docker0 !docker0  0.0.0.0/0            0.0.0.0/0
       0        0 ACCEPT     all  --  docker0 docker0  0.0.0.0/0            0.0.0.0/0

Chain OUTPUT (policy ACCEPT 282 packets, 622495 bytes)
    pkts      bytes target     prot opt in     out     source               destination

Chain DOCKER (1 references)
    pkts      bytes target     prot opt in     out     source               destination
     218    13193 ACCEPT     tcp  --  !docker0 docker0  0.0.0.0/0            192.168.42.41        tcp dpt:22280
 4868186 297463902 ACCEPT     tcp  --  !docker0 docker0  0.0.0.0/0            192.168.42.41        tcp dpt:20280
   78663 13128102 ACCEPT     tcp  --  !docker0 docker0  0.0.0.0/0            192.168.42.41        tcp dpt:22
      47     4321 ACCEPT     tcp  --  !docker0 docker0  0.0.0.0/0            192.168.42.41        tcp dpt:28159
[yaxin@ubox ~]$sudo iptables -t nat -nvxL
Chain PREROUTING (policy ACCEPT 210199 packets, 14035875 bytes)
    pkts      bytes target     prot opt in     out     source               destination
 1219483 82563968 DOCKER     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL

Chain INPUT (policy ACCEPT 197679 packets, 13316595 bytes)
    pkts      bytes target     prot opt in     out     source               destination

Chain OUTPUT (policy ACCEPT 271553 packets, 16671466 bytes)
    pkts      bytes target     prot opt in     out     source               destination
    1643    99251 DOCKER     all  --  *      *       0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCAL

Chain POSTROUTING (policy ACCEPT 271743 packets, 16682594 bytes)
    pkts      bytes target     prot opt in     out     source               destination
   13468   811013 MASQUERADE  all  --  *      !docker0  192.168.42.0/24      0.0.0.0/0
       0        0 MASQUERADE  tcp  --  *      *       192.168.42.41        192.168.42.41        tcp dpt:22280
       0        0 MASQUERADE  tcp  --  *      *       192.168.42.41        192.168.42.41        tcp dpt:20280
       0        0 MASQUERADE  tcp  --  *      *       192.168.42.41        192.168.42.41        tcp dpt:22
       0        0 MASQUERADE  tcp  --  *      *       192.168.42.41        192.168.42.41        tcp dpt:28159

Chain DOCKER (2 references)
    pkts      bytes target     prot opt in     out     source               destination
      22     1404 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:22280 to:192.168.42.41:22280
     288    17156 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:20280 to:192.168.42.41:20280
      93     5952 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:22222 to:192.168.42.41:22
       8      512 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:28159 to:192.168.42.41:28159
</code></pre>
<p>我们要做的就是根据自己container的情况配置iptables规则。</p>
<p>首先是<strong>filter</strong>这个表，我们要配置其放通转发，docker默认已经将所有的<em>FORWARD</em>规则放到了<em>DOCKER</em>这个自建链(chain)中了，这样方便配置，也方便查看。</p>
<p>然后再配置<strong>nat</strong>表为其配置<em>DNAT</em>，这个才是端口转发的核心配置。这个表中只需要配置<em>POSTROUTING</em>和<em>DOCKER</em>链即可，这里不讲为什么这么配置，如果想要深入了解iptables请google一下。</p>
<p>下面举个例子：</p>
<p>假如我有一个container，名字为nginx(通过运行<code>docker ps</code>命令即可查询)，现在我在docker内部运行nginx程序，监听了<em>8888</em>端口，我希望外网可以通过<em>8899</em>端口(注意一下端口)访问</p>
<ol>
<li>找到docker为nginx分配的IP</li>
</ol>
<pre><code class="language-bash">[yaxin@ubox ~]$sudo docker inspect -f '{{.NetworkSettings.IPAddress}}' nginx
192.168.42.43
</code></pre>
<ol start="2">
<li>配置iptables中filter表的FORWARD(DOCKER)链</li>
</ol>
<pre><code class="language-bash">[yaxin@ubox ~]$sudo iptables -A DOCKER ! -i docker0 -o docker0 -p tcp --dport 8888 -d 192.168.42.43 -j ACCEPT
</code></pre>
<ol start="3">
<li>配置iptables中nat表的PREROUTING(DOCKER)和POSTROUTING链</li>
</ol>
<pre><code class="language-bash">[yaxin@ubox ~]$sudo iptables -t nat -A POSTROUTING -p tcp --dport 8888 -s 192.168.42.43 -d 192.168.42.43 -j MASQUERADE
[yaxin@ubox ~]$sudo iptables -t nat -A DOCKER ! -i dokcer0 -p tcp --dport 8899 -j DNAT --to-destination 192.168.42.43:8888
</code></pre>
<ol start="4">
<li>
<p>通过外网访问<code>curl http://IP:8899</code>就会显示nginx下配置的html页面</p>
</li>
<li>
<p>最后iptables规则</p>
</li>
</ol>
<pre><code class="language-shell">[yaxin@ubox ~]$sudo iptables -nvxL
Chain INPUT (policy ACCEPT 67893 packets, 212661547 bytes)
    pkts      bytes target     prot opt in     out     source               destination
   14364   790008 DROP       tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:25

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
    pkts      bytes target     prot opt in     out     source               destination
 5479682 653269356 DOCKER     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0
   94186 314986910 ACCEPT     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED
 4705658 2183254076 ACCEPT     all  --  docker0 !docker0  0.0.0.0/0            0.0.0.0/0
       0        0 ACCEPT     all  --  docker0 docker0  0.0.0.0/0            0.0.0.0/0

Chain OUTPUT (policy ACCEPT 71253 packets, 222512872 bytes)
    pkts      bytes target     prot opt in     out     source               destination

Chain DOCKER (1 references)
    pkts      bytes target     prot opt in     out     source               destination
     218    13193 ACCEPT     tcp  --  !docker0 docker0  0.0.0.0/0            192.168.42.41        tcp dpt:22280
 4868186 297463902 ACCEPT     tcp  --  !docker0 docker0  0.0.0.0/0            192.168.42.41        tcp dpt:20280
   78663 13128102 ACCEPT     tcp  --  !docker0 docker0  0.0.0.0/0            192.168.42.41        tcp dpt:22
      47     4321 ACCEPT     tcp  --  !docker0 docker0  0.0.0.0/0            192.168.42.41        tcp dpt:28159
      27     4627 ACCEPT     tcp  --  !docker0 docker0  0.0.0.0/0            192.168.42.43        tcp dpt:8888
[yaxin@ubox ~]$sudo iptables -t nat -nvxL
Chain PREROUTING (policy ACCEPT 232 packets, 16606 bytes)
    pkts      bytes target     prot opt in     out     source               destination
 1220281 82620790 DOCKER     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL

Chain INPUT (policy ACCEPT 216 packets, 15671 bytes)
    pkts      bytes target     prot opt in     out     source               destination

Chain OUTPUT (policy ACCEPT 317 packets, 19159 bytes)
    pkts      bytes target     prot opt in     out     source               destination
    1644    99311 DOCKER     all  --  *      *       0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCAL

Chain POSTROUTING (policy ACCEPT 321 packets, 19367 bytes)
    pkts      bytes target     prot opt in     out     source               destination
   13512   813656 MASQUERADE  all  --  *      !docker0  192.168.42.0/24      0.0.0.0/0
       0        0 MASQUERADE  tcp  --  *      *       192.168.42.41        192.168.42.41        tcp dpt:22280
       0        0 MASQUERADE  tcp  --  *      *       192.168.42.41        192.168.42.41        tcp dpt:20280
       0        0 MASQUERADE  tcp  --  *      *       192.168.42.41        192.168.42.41        tcp dpt:22
       0        0 MASQUERADE  tcp  --  *      *       192.168.42.41        192.168.42.41        tcp dpt:28159
       0        0 MASQUERADE  tcp  --  *      *       192.168.42.43        192.168.42.43        tcp dpt:8888

Chain DOCKER (2 references)
    pkts      bytes target     prot opt in     out     source               destination
      22     1404 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:22280 to:192.168.42.41:22280
     288    17156 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:20280 to:192.168.42.41:20280
      93     5952 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:22222 to:192.168.42.41:22
       8      512 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:28159 to:192.168.42.41:28159
       4      208 DNAT       tcp  --  !dokcer0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:8899 to:192.168.42.43:8888

</code></pre>
<p>当然，使用手动配置也是比较麻烦的，所以我写了一个脚本来自动配置端口映射，使用方法脚本中有说明</p>
<pre><code class="language-bash">#!/bin/bash
# filename: docker_expose.sh

if [ `id -u` -ne 0 ];then
    echo &quot;[EROOR] Please use root to run this script&quot;
    exit 23
fi

if [ $# -ne 3 ];then
    echo &quot;Usage: $0 &lt;container_name&gt; &lt;add|del&gt; [[&lt;machine_ip&gt;:]&lt;machine_port&gt;:]&lt;container_port&gt;[/&lt;protocol_type&gt;]&quot;
    exit 1
fi

IPV4_RE='(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])'

container_name=$1
action=$2
arguments=$3

# check action
if [ &quot;$action&quot;x != &quot;add&quot;x -a &quot;$action&quot;x != &quot;del&quot;x ];then
    echo &quot;[ERROR] Please use add or del parameter to add port map or delete port map&quot;
    exit 654
fi
if [ &quot;$action&quot;x == &quot;add&quot;x ];then
    action=&quot;A&quot;
else
    action=&quot;D&quot;
fi

# get container ip by container name
container_ip=`docker inspect -f '{{.NetworkSettings.IPAddress}}' $container_name 2&gt; /dev/null`
if [ -z $container_ip ];then
    echo &quot;[ERROR] Get container's (${container_name}) IP error, please ensure you have this container&quot;
    exit 2
fi

# parse arguments
protocol_type=`echo $arguments | awk -F '/' '{print $2}'`
if [ -z $protocol_type ];then
    protocol_type=&quot;tcp&quot;
fi

# check protocol
if [ &quot;$protocol_type&quot;x != &quot;tcp&quot;x -a &quot;$protocol_type&quot;x != &quot;udp&quot;x ];then
    echo &quot;[ERROR] Only tcp or udp protocol is allowed&quot;
    exit 99
fi

machine_ip=''
machine_port=''
container_port=''
# split the left arguments
arguments=${arguments%/*}
machine_ip=`echo $arguments | awk -F ':' '{print $1}'`
machine_port=`echo $arguments | awk -F ':' '{print $2}'`
container_port=`echo $arguments | awk -F ':' '{print $3}'`
if [ -z $machine_port ];then
    # arguments is: 234
    container_port=$machine_ip
    machine_port=$machine_ip
    unset machine_ip
elif [ -z $container_port ];then
    # arguments is: 234:456
    container_port=$machine_ip
    machine_port=$machine_port
    unset machine_ip
fi

# check port number function
_check_port_number() {
    local port_num=$1
    if ! echo $port_num | egrep &quot;^[0-9]+$&quot; &amp;&gt; /dev/null;then
        echo &quot;[ERROR] Invalid port number $port_num&quot;
        exit 3
    fi
    if [ $port_num -gt 65535 -o $port_num -lt 1 ];then
        echo &quot;[ERROR] Port number $port_num is out of range(1-56635)&quot;
        exit 4
    fi
}

# check port and ip address
_check_port_number $container_port
_check_port_number $machine_port

if [ ! -z $machine_ip ];then
    if ! echo $machine_ip | egrep &quot;^${IPV4_RE}$&quot; &amp;&gt; /dev/null;then
        echo &quot;[ERROR] Invalid Ip Adress $machine_ip&quot;
        exit 5
    fi

    # check which interface bind the IP
    for interface in `ifconfig -s | sed -n '2,$p' | awk '{print $1}'`;do
        interface_ip=`ifconfig $interface | awk '/inet addr/{print substr($2,6)}'`
        if [ &quot;$interface_ip&quot;x == &quot;$machine_ip&quot;x ];then
            interface_name=$interface
            break
        fi
    done

    if [ -z $interface_name ];then
        echo &quot;[ERROR] Can not find interface bind with $machine_ip&quot;
        exit 98
    fi
fi

# run iptables command
echo &quot;[INFO] Now start to change rules to iptables&quot;
echo &quot;[INFO] Changing POSTROUTING chain of nat table&quot;
iptables -t nat -${action} POSTROUTING -p ${protocol_type} --dport ${container_port} -s ${container_ip} -d ${container_ip} -j MASQUERADE
if [ -z $interface_name ];then
    echo &quot;[INFO] Changing DOCKER chain of filter table&quot;
    iptables -${action} DOCKER ! -i docker0 -o docker0 -p ${protocol_type} --dport ${container_port} -d ${container_ip} -j ACCEPT
    echo &quot;[INFO] Changing DOCKER chain of nat table&quot;
    iptables -t nat -${action} DOCKER ! -i docker0 -p ${protocol_type} --dport ${machine_port} -j DNAT --to-destination ${container_ip}:${container_port}
else
    echo &quot;[INFO] Changing DOCKER chain of filter table&quot;
    iptables -${action} DOCKER -i $interface_name -o docker0 -p ${protocol_type} --dport ${container_port} -d ${container_ip} -j ACCEPT
    echo &quot;[INFO] Changing DOCKER chain of nat table&quot;
    iptables -t nat -${action} DOCKER -i $interface_name -p ${protocol_type} --dport ${machine_port} -j DNAT --to-destination ${container_ip}:${container_port}
fi
</code></pre>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Linux/expose-port-of-running-docker-container.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Nginx下禅道的伪静态(rewrite)规则]]></title>
      <link>http://yaxin-cn.github.io/Nginx/configure-static-access-for-zentao-under-nginx.html</link>
      <guid>http://yaxin-cn.github.io/Nginx/configure-static-access-for-zentao-under-nginx.html</guid>
      <pubDate>Fri, 15 Jan 2016 02:06:52 GMT</pubDate>
      <description>
      <![CDATA[<p>搭建了一个禅道的项目管理平台，但是Nginx下并不是伪静态的，URL看着不是很舒服，上网搜索配置规则，但是没有一个可以正常使用的，于是乎自己琢磨一下。</p>
<p>先给出最终配置，有兴趣看原因的可以往下看</p>
<pre><code class="language-co]]>
      </description>
      <content:encoded><![CDATA[<p>搭建了一个禅道的项目管理平台，但是Nginx下并不是伪静态的，URL看着不是很舒服，上网搜索配置规则，但是没有一个可以正常使用的，于是乎自己琢磨一下。</p>
<p>先给出最终配置，有兴趣看原因的可以往下看</p>
<pre><code class="language-conf">server {
    listen 80;
    root /zentao/root/path/www;
    index index.php index.html index.htm;
    server_name domain_name;

    location / {
        try_files $uri /index.php$uri;
    }

    location ~ \.php(/.+)?$ {
        fastcgi_pass unix:/var/run/php-fpm.sock;
        fastcgi_index index.php;
        include fastcgi.conf;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_param PATH_INFO $fastcgi_path_info;
    }
    access_log off;
}
</code></pre>
<p>禅道给出了apache的伪静态规则，但是我尝试了半天也没有转换成可用的nginx伪静态规则，但是禅道是基于PHP的，而PHP伪静态一般基于<code>$_SERVER</code>变量中的一些变量来实现的，既然apache可以实现伪静态，那么就打印一下伪静态后的<code>$_SERVER</code>变量的值。</p>
<p>修改禅道根目录下<code>www/index.php</code>文件，在最上面修改为如下代码:</p>
<pre><code class="language-php">&lt;?php
    echo &quot;&lt;pre&gt;&quot;;
    print_r($_SERVER);
    echo &quot;&lt;/pre&gt;&quot;;
    die;
</code></pre>
<p>然后访问http://domain/user-login-Lw==.html (此为禅道登陆url)</p>
<pre><code class="language-php">// 仅给出几个重要的变量
Array
(
    [REDIRECT_URL] =&gt; /user-login-Lw==.html
    [REQUEST_URI] =&gt; /user-login-Lw==.html
    [SCRIPT_NAME] =&gt; /index.php
    [PATH_INFO] =&gt; /user-login-Lw==.html
    [PATH_TRANSLATED] =&gt; redirect:/index.php/user-login-Lw==.html
    [PHP_SELF] =&gt; /index.php/user-login-Lw==.html
)
</code></pre>
<p>对于未配置过的nginx做相同的操作:</p>
<p><strong>未配置的nginx并不是什么都没配置，基本的还是要配置的</strong></p>
<pre><code class="language-nginx">    location / {
        try_files $uri /index.php;
    }
    location ~ \.php$ {
        # With php5-fpm:
        fastcgi_pass unix:/var/run/php-fpm.sock;
        fastcgi_index index.php;
        include fastcgi.conf;
    }
</code></pre>
<p>如上，这两个location还是要有的，一个是将所有的请求重定向到<code>index.php</code>，一个是解析php文件的.</p>
<p>这次，php返回的信息为</p>
<pre><code class="language-php">// 仅给出几个重要的变量
Array
(
    [SCRIPT_NAME] =&gt; /index.php
    [REQUEST_URI] =&gt; /user-login-Lw==.html
    [DOCUMENT_URI] =&gt; /index.php
    [PHP_SELF] =&gt; /index.php
)
</code></pre>
<p>对比一下，发现不同了吧。nginx少了<code>PATH_INFO</code>，而且<code>PHP_SELF</code>也是不一样的，至于<code>REDIRECT_URL</code>和<code>PATH_TRANSLATED</code>这些变量都是apache自己加的，禅道并不会用到。</p>
<p>回想一下禅道的配置文件<code>config/config.php</code>和<code>config/my.php</code>中有一项<code>$config-&gt;requestType</code>配置，如果配置为**<code>GET</code><strong>的话，就会禁用伪静态，而通过query string的方式，如果配置成</strong><code>PATH_INFO</code>**的话就需要nginx或apache配置伪静态规则，也就是说禅道通过解析PATH_INFO来实现伪静态的。</p>
<p>那么PATH_INFO又是什么东东，根据<a href="http://php.net/manual/zh/reserved.variables.server.php" target="_blank" rel="external">PHP官方文档</a>的解释，如果我访问http://www.example.com/php/path_info.php/some/stuff?foo=bar这个url，那个PATH_INFO就应该等于/some/stuff，也就是所<code>PATH_INFO</code>等于url中跟在真实脚本名称之后并且在查询语句（query string）之前的字符串，你可能会说，我访问的url中根本没有filename.php啊，那是因为nginx帮你添加了，记得配置中的<code>try_files $uri /index.php$uri</code>吧，这个内部跳转就是干这个事情的。</p>
<p>找到了原因就开始解决，Nginx和PHP是通过cgi协议传递数据的，可以通过nginx开启<a href="http://nginx.org/en/docs/debugging_log.html" target="_blank" rel="external">debug</a> (<a href="http://nginx.org/en/docs/debugging_log.html" target="_blank" rel="external">http://nginx.org/en/docs/debugging_log.html</a>)来查看传递nginx和php交换的数据。</p>
<p>这里不给出详细debug log了，反正开启log后发现nginx并没有传递PATH_INFO给php，于是在解析php的location中添加一行</p>
<pre><code class="language-nginx">    location ~ \.php$ {
        fastcgi_pass unix:/var/run/php-fpm.sock;
        fastcgi_index index.php;
        include fastcgi.conf;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_param PATH_INFO $fastcgi_path_info;
    }
</code></pre>
<p>但只有这个还是不行，因为此时nginx内部变量<code>$uri</code>(就相当于PHP_SELF的值)还是*/index.php*，需要再修改一个地方</p>
<pre><code class="language-nginx">    location / {
        try_files $uri /index.php;
    }
</code></pre>
<p>修改之后php那个location就没办法被识别了，需要修改为<code>\.php(/.+)?$</code></p>
<p>最终的效果就是</p>
<pre><code class="language-conf">server {
    listen 80;
    root /zentao/root/path/www;
    index index.php index.html index.htm;
    server_name domain_name;

    location / {
        try_files $uri /index.php$uri;
    }

    location ~ \.php(/.+)?$ {
        fastcgi_pass unix:/var/run/php-fpm.sock;
        fastcgi_index index.php;
        include fastcgi.conf;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_param PATH_INFO $fastcgi_path_info;
    }
    access_log off;
}
</code></pre>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Nginx/configure-static-access-for-zentao-under-nginx.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[python安装cffi模块的一个问题]]></title>
      <link>http://yaxin-cn.github.io/Python/issue-when-install-python-cffi.html</link>
      <guid>http://yaxin-cn.github.io/Python/issue-when-install-python-cffi.html</guid>
      <pubDate>Mon, 28 Sep 2015 05:10:45 GMT</pubDate>
      <description>
      <![CDATA[<p>系统自带的python有点老（2.6）于是下载python2.7.8的源码手动编译安装(编译参数<code>./configure --enable-shared --disable-ipv6 --prefix=/usr/local/python27 --enable-un]]>
      </description>
      <content:encoded><![CDATA[<p>系统自带的python有点老（2.6）于是下载python2.7.8的源码手动编译安装(编译参数<code>./configure --enable-shared --disable-ipv6 --prefix=/usr/local/python27 --enable-unicode=ucs4</code>)</p>
<p>安装后将系统的python替换(<code>ln -svf /usr/local/python27/bin/* /usr/bin/</code>), 安装<a href="https://bootstrap.pypa.io/ez_setup.py" target="_blank" rel="external">easy_install</a>和pip(<code>easy_install pip</code>), 之后开始安装<em>pyopenssl</em>, 但是在安装依赖<em>cffi</em>的时候报错**/usr/bin/ld: cannot find -lpython2.7**.</p>
<p>首先需要说明的是出现类似**/usr/bin/ld: cannot find -lxx**的原因主要是gcc没有找到libxx.so的文件</p>
<pre><code class="language-bash">[root@ubox ~]# echo '/usr/local/python27/lib' &gt; /etc/ld.so.conf.d/python-2.7.8.conf
[root@ubox ~]# ldconfig -v
</code></pre>
<p><code>ldconfig</code>命令为重建动态链接库的缓存.然后重新执行<code>pip install cffi</code>, 但是还是报错, 使用<code>gcc -lpython2.7 --verbose</code>查看gcc查找库的路径</p>
<pre><code class="language-bash">[root@ubox lib]# gcc -lpython2.7 --verbose
Using built-in specs.
Target: x86_64-redhat-linux
Configured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-languages=c,c++,objc,obj-c++,java,fortran,ada --enable-java-awt=gtk --disable-dssi --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-1.5.0.0/jre --enable-libgcj-multifile --enable-java-maintainer-mode --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --disable-libjava-multilib --with-ppl --with-cloog --with-tune=generic --with-arch_32=i686 --build=x86_64-redhat-linux
Thread model: posix
gcc version 4.4.7 20120313 (Red Hat 4.4.7-16) (GCC)
COMPILER_PATH=/usr/libexec/gcc/x86_64-redhat-linux/4.4.7/:/usr/libexec/gcc/x86_64-redhat-linux/4.4.7/:/usr/libexec/gcc/x86_64-redhat-linux/:/usr/lib/gcc/x86_64-redhat-linux/4.4.7/:/usr/lib/gcc/x86_64-redhat-linux/:/usr/libexec/gcc/x86_64-redhat-linux/4.4.7/:/usr/libexec/gcc/x86_64-redhat-linux/:/usr/lib/gcc/x86_64-redhat-linux/4.4.7/:/usr/lib/gcc/x86_64-redhat-linux/
LIBRARY_PATH=/usr/lib/gcc/x86_64-redhat-linux/4.4.7/:/usr/lib/gcc/x86_64-redhat-linux/4.4.7/:/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../lib64/:/lib/../lib64/:/usr/lib/../lib64/:/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../:/lib/:/usr/lib/
COLLECT_GCC_OPTIONS='-v' '-mtune=generic'
 /usr/libexec/gcc/x86_64-redhat-linux/4.4.7/collect2 --eh-frame-hdr --build-id -m elf_x86_64 --hash-style=gnu -dynamic-linker /lib64/ld-linux-x86-64.so.2 /usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../lib64/crt1.o /usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../lib64/crti.o /usr/lib/gcc/x86_64-redhat-linux/4.4.7/crtbegin.o -L/usr/lib/gcc/x86_64-redhat-linux/4.4.7 -L/usr/lib/gcc/x86_64-redhat-linux/4.4.7 -L/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../lib64 -L/lib/../lib64 -L/usr/lib/../lib64 -L/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../.. -lpython2.7 -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-redhat-linux/4.4.7/crtend.o /usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../lib64/crtn.o
/usr/bin/ld: cannot find -lpython2.7
collect2: ld returned 1 exit status
</code></pre>
<p>可以看到**/usr/local/python27/lib**并不在上面的路径, google一下找到了这个答案<a href="http://stackoverflow.com/questions/8400272/usr-bin-ld-cannot-find-lpython2-7" target="_blank" rel="external">http://stackoverflow.com/questions/8400272/usr-bin-ld-cannot-find-lpython2-7</a>, 然后</p>
<pre><code class="language-bash">[root@micaopan-dev lib]# locate libpython2.7.a
/usr/local/python27/lib/python2.7/config/libpython2.7.a
/usr/local/src/Python-2.7.8/libpython2.7.a
[root@micaopan-dev lib]# ln -s /usr/local/python27/lib/python2.7/config/libpython2.7.a /usr/lib
[root@micaopan-dev lib]# gcc -lpython2.7 --verbose
...
(.text+0x20): undefined reference to 'main'
collect2: ld returned 1 exit status
</code></pre>
<p>这个gcc找到了动态链接库, 报错根据<a href="http://stackoverflow.com/questions/15905119/c-linking-error-undefined-reference-to-main" target="_blank" rel="external">http://stackoverflow.com/questions/15905119/c-linking-error-undefined-reference-to-main</a>应该并没有什么大碍</p>
<p>然后执行<code>pip install cffi</code>成功.</p>
<p>PS: 参考</p>
<ol>
<li><a href="http://navyaijm.blog.51cto.com/4647068/809424" target="_blank" rel="external">/usr/bin/ld: cannot find -l* 错误的解决方法……</a></li>
<li><a href="http://eminzhang.blog.51cto.com/5292425/1285705" target="_blank" rel="external">关于usr/bin/ld: cannot find -lxxx问题总结</a></li>
<li><a href="http://stackoverflow.com/questions/8400272/usr-bin-ld-cannot-find-lpython2-7" target="_blank" rel="external">/usr/bin/ld: cannot find -lpython2.7</a></li>
<li><a href="http://stackoverflow.com/questions/15905119/c-linking-error-undefined-reference-to-main" target="_blank" rel="external">C Linking Error: undefined reference to 'main'</a></li>
</ol>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Python/issue-when-install-python-cffi.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Ubuntu添加可信任根证书]]></title>
      <link>http://yaxin-cn.github.io/Linux/add-root-certificate-in-ubuntu.html</link>
      <guid>http://yaxin-cn.github.io/Linux/add-root-certificate-in-ubuntu.html</guid>
      <pubDate>Thu, 21 May 2015 03:58:45 GMT</pubDate>
      <description>
      <![CDATA[<h2>添加</h2>
<p>Ubuntu下添加根证书非常简单, 只要将证书(扩展名为crt)复制到**/usr/local/share/ca-certificates**文件夹然后运行<code>update-ca-certificates</code>即可</p>
<pre>]]>
      </description>
      <content:encoded><![CDATA[<h2>添加</h2>
<p>Ubuntu下添加根证书非常简单, 只要将证书(扩展名为crt)复制到**/usr/local/share/ca-certificates**文件夹然后运行<code>update-ca-certificates</code>即可</p>
<pre><code class="language-bash">[yaxin@ubox ~]$sudo cp xinmu.crt /usr/local/share/ca-certificates
[yaxin@ubox ~]$sudo update-ca-certificates
Updating certificates in /etc/ssl/certs... 1 added, 0 removed; done.
Running hooks in /etc/ca-certificates/update.d....done.
</code></pre>
<h2>删除</h2>
<p>直接将**/usr/local/share/ca-certificates**对应的证书删除，然后执行<code>update-ca-certificates</code></p>
<pre><code class="language-bash">[yaxin@ubox ~]$sudo rm -f /usr/local/share/ca-certificates/xinmu.crt
[yaxin@ubox ~]$sudo update-ca-certificates
Updating certificates in /etc/ssl/certs... 0 added, 0 removed; done.
Running hooks in /etc/ca-certificates/update.d....done.
</code></pre>
<p><strong>注意: 这时候并不会提示1 removed, 但证书是已经被删除了的</strong></p>
<h2>原理</h2>
<p>其实<code>update-ca-certificates</code>是一个shell脚本, 使用<code>which</code>找出<code>update-ca-certificates</code>的绝对路径，然后打开就可以查看其源码</p>
<pre><code class="language-bash">[yaxin@ubox ~]$which update-ca-certificates
/usr/sbin/update-ca-certificates
[yaxin@ubox ~]$file /usr/sbin/update-ca-certificates
/usr/sbin/update-ca-certificates: POSIX shell script, ASCII text executable
</code></pre>
<p>通过阅读源码可以看出, <code>update-ca-certificates</code>命令的本质其实是将PEM格式的根证书内容附加到*/etc/ssl/certs/ca-certificates.crt*, 而*/etc/ssl/certs/ca-certificates.crt*中本身就包含了系统自带的各种可信根证书.</p>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Linux/add-root-certificate-in-ubuntu.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[管理ubuntu server自启程序]]></title>
      <link>http://yaxin-cn.github.io/Linux/manage-startup-program-on-ubuntu-server.html</link>
      <guid>http://yaxin-cn.github.io/Linux/manage-startup-program-on-ubuntu-server.html</guid>
      <pubDate>Wed, 13 May 2015 12:28:30 GMT</pubDate>
      <description>
      <![CDATA[<p>本文所使用的环境为ubuntu14.04，ubuntu15.04使用systemd，可能会有很大的不同</p>
<h2>方法一</h2>
<p>使用类图形的<code>sysv-rc-conf</code>命令，你需要首先安装<code>sysv-rc-conf</code]]>
      </description>
      <content:encoded><![CDATA[<p>本文所使用的环境为ubuntu14.04，ubuntu15.04使用systemd，可能会有很大的不同</p>
<h2>方法一</h2>
<p>使用类图形的<code>sysv-rc-conf</code>命令，你需要首先安装<code>sysv-rc-conf</code></p>
<pre><code class="language-bash">[yaxin@~]$sudo apt-get install sysv-rc-conf
[yaxin@~]$sudo sysv-rc-conf
</code></pre>
<p>运行之后会有一个类图形的界面, 这个操作起来相当简单, 也容易懂，这里就不多介绍</p>
<h2>方法二</h2>
<p>首先使用<code>runlevel</code>命令获取系统运行在哪个<strong>level</strong>下（ubuntu server一般是2），如下：</p>
<pre><code class="language-bash">[yaxin@~]$runlevel
N 2
[yaxin@~]$
</code></pre>
<p>然后将启动脚本放到<code>/etc/rcX.d</code> 其中X为运行级别，如<code>/etc/rc2.d</code>, 注意脚本要以大写<strong>S</strong>开头, 后面接一个两位数的数字，表示启动顺序，数字越小表示越先启动</p>
<p>一般<code>/etc/rc2.d</code>中会有很多软链接到<code>/etc/init.d</code>下的启动脚本, 这样的好处是集中管理，很方便, 并且可以使用<code>service</code>这个程序对进程进行重启等操作.</p>
<p>如，编译安装完php后，将<code>sapi/fpm</code>文件夹下的<code>init.d.php-fpm</code>文件复制到<code>/etc/init.d</code>文件夹下，然后在<code>/etc/rc2.d</code>下创建一个软链接</p>
<pre><code class="language-bash">[yaxin@php-5.6.8]$sudo cp sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm
[yaxin@php-5.6.8]$sudo chmod +x /etc/init.d/php-fpm
[yaxin@php-5.6.8]$sudo ln -s /etc/init.d/php-fpm /etc/rc2.d/S20php-fpm
[yaxin@php-5.6.8]$service php-fpm start
</code></pre>
<p>当然，如果你想关闭一个自启的程序，直接将对应的<code>/etc/rcX.d</code>下的启动脚本删除即可</p>
<pre><code class="language-bash">[yaxin@~]$sudo rm /etc/rc2.d/S20php-fpm
</code></pre>
<p>或则</p>
<pre><code class="language-bash">[yaxin@~]$sudo unlink /etc/rc2.d/S20php-fpm
</code></pre>
<p><strong>注意</strong>: <code>sysv-rc-conf</code>命令就是使用这个方法来实现程序自启和禁止自启的.</p>
<h2>方法三</h2>
<p>直接将需要启动的程序添加到<code>/etc/rc.local</code>文件中</p>
<p>如你需要开机启动nginx，那么可以这样</p>
<pre><code class="language-bash">[root@~]$echo &quot;/etc/nginx/sbin/nginx&quot; &gt;&gt; /etc/rc.local
</code></pre>
<p>其实这个就是方法二的快捷操作，如果你查看<code>/etc/rc2.d</code>文件夹下面的文件会发现有一个<code>S99rc.local</code>的软链接，它链接到<code>/etc/init.d/rc.local</code>, 而<code>/etc/init.d/rc.local</code>这个脚本中又会执行<code>/etc/rc.local</code>这个脚本</p>
<h3>方法四</h3>
<p>其实前几种方式并不是正统的自启管理方式, 使用<code>rcX.d</code>是<strong>传统init</strong>的方式, 而ubuntu14.04是使用<strong>Upstart</strong>来初始化守护进程, 但为了照顾使用从<strong>init</strong>过来(如centos6等)的人才创建的. 而真正的启动脚本(应该说配置)是放在<code>/etc/init</code>这个文件夹下的</p>
<p><code>/etc/init</code>文件夹下有很多的以**.conf**结尾的文件，这些就是正统的管理自启程序的配置文件.</p>
<p>随便打开一个文件, 有一行<strong>start on runlevel [234]</strong>, 这就说明在runlevel为234的情况下启动</p>
<pre><code class="language-bash">[yaxin@/etc/init]$head ssh.conf
# ssh - OpenBSD Secure Shell server
#
# The OpenSSH server provides secure shell access to the system.

description &quot;OpenSSH server&quot;

start on runlevel [2345]
stop on runlevel [!2345]
</code></pre>
<p>如上，ssh将在runlevel为2 3 4 5的时候开机启动, 而启动的具体命令在配置文件后面.</p>
<p>当然，如果你想关闭自启，那么删除但钱runlevel即可，或则直接删除该配置文件.</p>
<p>所以，如果你有一个开机自启的程序，当你使用前面的方法删除以后，程序还是自启，那么问题肯定出在这一步.</p>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Linux/manage-startup-program-on-ubuntu-server.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Python中的类方法和静态方法]]></title>
      <link>http://yaxin-cn.github.io/Python/classmethod-and-staticmethod-in-python.html</link>
      <guid>http://yaxin-cn.github.io/Python/classmethod-and-staticmethod-in-python.html</guid>
      <pubDate>Mon, 22 Dec 2014 03:41:56 GMT</pubDate>
      <description>
      <![CDATA[<p>Python类中有两个特殊的修饰符@classmethod和@staticmethod(即类方法和静态方法), 想要理解需要先理解类属性和实例属性的感念</p>
<h2>类属性和实例属性</h2>
<p>看下面的代码</p>
<pre><code class="langua]]>
      </description>
      <content:encoded><![CDATA[<p>Python类中有两个特殊的修饰符@classmethod和@staticmethod(即类方法和静态方法), 想要理解需要先理解类属性和实例属性的感念</p>
<h2>类属性和实例属性</h2>
<p>看下面的代码</p>
<pre><code class="language-python">&gt;&gt;&gt; class TestProperty(object):
...     class_property = &quot;class property&quot;
...     
...     def __init__(self):
...         self.instance_property = &quot;instance property&quot;
&gt;&gt;&gt; 
&gt;&gt;&gt; test_property = TestProperty()
&gt;&gt;&gt; # 实例可以访问实例属性和类属性
&gt;&gt;&gt; print test_property.class_property
class property
&gt;&gt;&gt; print test_property.instance_property
instance property
&gt;&gt;&gt; # 类可以访问类属性
&gt;&gt;&gt; print TestProperty.class_property
class property
&gt;&gt;&gt; # 但不可以访问实例属性
&gt;&gt;&gt; print TestProperty.instance_property
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: type object 'TestProperty' has no attribute 'instance_property'
&gt;&gt;&gt; # 注意下面的报错
&gt;&gt;&gt; del test_property.class_property
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: class_property
</code></pre>
<p>总结起来就是:</p>
<ol>
<li><strong>实例属性</strong>的初始化在<code>__init__</code>构造器方法中进行(当然也可以通过其它方法赋值)</li>
<li><strong>类实例</strong>可以访问实例属性和类属性</li>
<li>通过类本身则能访问类属性,无法访问实例属性</li>
<li>类属性与类实例没有任何关系</li>
<li>类属性其实就是其它语言中的静态变量(变量前加static)</li>
<li>为什么要有类属性, 一句话<strong>命名空间</strong></li>
</ol>
<h2>类方法和静态方法</h2>
<pre><code class="language-python">&gt;&gt;&gt; class TestMethod(object):
...     class_property = &quot;class property&quot;
...     def __init__(self):
...         self.instance_property = &quot;instance property&quot;
...     def instance_method(self, arvg):
...         print &quot;instance_method(%s, %s)&quot; % (self, arvg)
...         print &quot;instance property: &quot;, self.instance_property
...     @classmethod
...     def class_method(cls, arvg):
...         print &quot;class_method(%s, %s)&quot; % (cls, arvg)
...         print &quot;class property: &quot;, cls.class_property
...     @staticmethod
...     def static_method(arvg):
...         print &quot;static_method(%s)&quot; % arvg
... 
&gt;&gt;&gt;
&gt;&gt;&gt; test_method = TestMethod()
&gt;&gt;&gt; # 执行普通方法, 打印出实例的内存地址和实例属性
&gt;&gt;&gt; test_method.instance_method(&quot;Hello&quot;)
instance_method(&lt;__main__.TestMethod object at 0x7fd8fc56eb90&gt;, Hello)
instance property:  instance property
&gt;&gt;&gt; # 执行类方法
&gt;&gt;&gt; # 通过实例访问, 打印出类本身和类属性
&gt;&gt;&gt; test_method.class_method(&quot;Hello&quot;)
class_method(&lt;class '__main__.TestMethod'&gt;, Hello)
class property:  class property
&gt;&gt;&gt; # 通过类直接访问, 同上
&gt;&gt;&gt; TestMethod.class_method(&quot;Hello&quot;)
class_method(&lt;class '__main__.TestMethod'&gt;, Hello)
class property:  class property
&gt;&gt;&gt; # 执行静态方法
&gt;&gt;&gt; # 通过实例访问, 打印出静态方法本身
&gt;&gt;&gt; test_method.static_method(&quot;Hello&quot;)
static_method(Hello)
&gt;&gt;&gt; # 通过类直接访问, 同上
&gt;&gt;&gt; TestMethod.static_method(&quot;Hello&quot;)
static_method(Hello)
</code></pre>
<p>可以看出类方法中<code>cls</code>代表的是类本身, 如果将类方法中的访问类属性的cls去掉, 则会报出<em>NameError</em>的错误</p>
<pre><code class="language-python">&gt;&gt;&gt; class TestMethod(object):
...     class_property = &quot;class property&quot;
...     @classmethod
...     def class_method(cls, arvg):
...         print &quot;class property: &quot;, cls.class_property
... 
&gt;&gt;&gt; TestMethod.class_method(&quot;Hello&quot;)
class property: 
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;stdin&gt;&quot;, line 5, in class_method
NameError: global name 'class_property' is not defined
</code></pre>
<ol>
<li><strong>类方法是为了访问类属性更加方便</strong></li>
<li>类方法和静态方法可以通过类和实例来访问,效果是相同的</li>
<li>静态方法跟普通函数没有什么区别</li>
</ol>
<p>可以通过在实例方法中直接通过<code>TestMethod.class_property</code>来访问, 但是这样不方便也不好维护(如果类名称改了,就会出错), 也可以使用<code>self.class_property</code>来访问, 但注意, 实例本身获取的并不应该是类属性即<code>TestMethod.class_property</code>, 只是因为实例中并没有<code>class_property</code>这个变量, 而是通过查找类属性,发现有同名变量,然后打印出来,通过上面无法实例无法删除类属性是可以看出来的. 当然,如果不信,可以看下面的例子</p>
<pre><code class="language-python">&gt;&gt;&gt; class TestMethod(object):
...     class_property = &quot;class property&quot;
...     def __init__(self):
...         pass
... 
&gt;&gt;&gt; test_method = TestMethod()
&gt;&gt;&gt; id(test_method.class_property)
140488040794968
&gt;&gt;&gt; id(TestMethod.class_property)
140488040794968
&gt;&gt;&gt; print test_method.class_property
class property
&gt;&gt;&gt; test_method.class_property = test_method.class_property + &quot;!!!&quot;
&gt;&gt;&gt; print test_method.class_property
class property!!!
&gt;&gt;&gt; print TestMethod.class_property
class property
&gt;&gt;&gt; id(test_method.class_property)
140488040795080
&gt;&gt;&gt; id(TestMethod.class_property)
140488040794968
</code></pre>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Python/classmethod-and-staticmethod-in-python.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Docker中使用固定IP]]></title>
      <link>http://yaxin-cn.github.io/Docker/docker-container-use-static-IP.html</link>
      <guid>http://yaxin-cn.github.io/Docker/docker-container-use-static-IP.html</guid>
      <pubDate>Thu, 11 Dec 2014 06:14:08 GMT</pubDate>
      <description>
      <![CDATA[<p>默认情况下启动一个container，其会自动获取一个跟<code>docker0</code>同网段的IP，而且重启container其IP一般会发生变化，但有时候我们会需要固定的IP。要实现这个并不困难。</p>
<p><a href="https://docs.doc]]>
      </description>
      <content:encoded><![CDATA[<p>默认情况下启动一个container，其会自动获取一个跟<code>docker0</code>同网段的IP，而且重启container其IP一般会发生变化，但有时候我们会需要固定的IP。要实现这个并不困难。</p>
<p><a href="https://docs.docker.com/reference/commandline/cli/#run" target="_blank" rel="external"><code>docker run</code></a>启动一个container的命令有一个<code>--net</code>的参数用于指定container的网络类型</p>
<blockquote>
<p>--net=&quot;bridge&quot;  Set the Network mode for the container
     'bridge': creates a new network stack for the container on the docker bridge
     'none': no networking for this container
     'container:&lt;name|id&gt;': reuses another container network stack
     'host': use the host network stack inside the container.  Note: the host mode gives the container full access to local system services such as D-bus and is therefore considered insecure.</p>
</blockquote>
<p>docker默认使用'bridge'来设置container的网络模式（即从与docker0同网段的未使用的IP中取一个作为container的IP），我们这里使用'<strong>none</strong>'来实现自己手动配置container的网络。</p>
<p>首先我们以**<code>--net='none'</code>**的方式启动一个container</p>
<pre><code class="language-shell">[yaxin@cube2x ~]$docker run -i -t --rm --net='none' ubuntu /bin/bash
root@db84e747c362:/# ifconfig -a
lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

root@db84e747c362:/#
</code></pre>
<p>可以看到，由于我们使用'none'模式，container中没有获取到IP，甚至连网卡都没有，下面我们开始给container配置IP</p>
<p>首先获取container的pid（我们需要通过pid获取file descriptor）</p>
<pre><code class="language-bash">[yaxin@cube2x ~]$docker ps
CONTAINER ID        IMAGE                            COMMAND             CREATED             STATUS              PORTS               NAMES
db84e747c362        docker.cn/docker/ubuntu:latest   &quot;/bin/bash&quot;         4 minutes ago       Up 4 minutes                            sharp_kirch
[yaxin@cube2x ~]$docker inspect -f "{{.State.Pid}}" sharp_kirch
23090
</code></pre>
<p>ip-netns的man page中有这样一句</p>
<blockquote>
<p>By convention a named network namespace is an object at /var/run/netns/NAME that can be opened.  The file descriptor resulting from opening/var/run/netns/NAME refers to the specified network namespace</p>
</blockquote>
<p>因而我们需要创建一个链接</p>
<pre><code class="language-shell">[yaxin@cube2x ~]$sudo ln -s /proc/23090/ns/net /var/run/netns/23090
</code></pre>
<p>然后创建一对端到端的网卡，将<code>veth_db84e747c3</code>绑定到docker0网桥，并启动。将另一块网卡<code>X</code>放到container内部</p>
<pre><code class="language-shell">[yaxin@cube2x ~]$sudo ip link add veth_db84e747c3 type veth peer name X
[yaxin@cube2x ~]$sudo brctl addif docker0 veth_db84e747c3
[yaxin@cube2x ~]$sudo ip link set veth_db84e747c3 up
[yaxin@cube2x ~]$sudo ip link set X netns 23090
</code></pre>
<p>这时查看container的IP，会发现多了一个名为<code>X</code>的网卡</p>
<pre><code class="language-shell">root@db84e747c362:/# ifconfig  -a
X         Link encap:Ethernet  HWaddr 5a:7e:4d:ba:63:1c  
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

root@db84e747c362:/#
</code></pre>
<p>然后对container内部新添加的网卡进行配置（可以通过<code>man ip-netns</code>更详细查看）</p>
<pre><code>[yaxin@cube2x ~]$sudo ip netns exec 23090 ip link set dev X name eth0
[yaxin@cube2x ~]$sudo ip netns exec 23090 ip link set eth0 up
[yaxin@cube2x ~]$sudo ip netns exec 23090 ip addr add 172.17.111.10/16 dev eth0
[yaxin@cube2x ~]$sudo ip netns exec 23090 ip route add default via 172.17.42.1
</code></pre>
<p><strong>注意: 指定给container的IP必须跟docker0在同一网段,且给container的网关应该为docker0的IP</strong></p>
<p>最后，写成shell脚本如下:</p>
<pre><code class="language-shell">#!/usr/bin/env bash
# filename: bind_addr.sh

if [ `id -u` -ne 0 ];then
    echo '必须使用root权限'
    exit
fi

if [ $# != 2 ]; then
    echo &quot;使用方法: $0 容器名字 IP&quot;
    exit 1
fi

container_name=$1
bind_ip=$2

container_id=`docker inspect -f '{{.Id}}' $container_name 2&gt; /dev/null`
if [ ! $container_id ];then
    echo &quot;容器不存在&quot;
    exit 2
fi
bind_ip=`echo $bind_ip | egrep '^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$'`
if [ ! $bind_ip ];then
    echo &quot;IP地址格式不正确&quot;
    exit 3
fi

container_minid=`echo $container_id | cut -c 1-10`
container_netmask=`ip addr show docker0 | grep &quot;inet\b&quot; | awk '{print $2}' | cut -d / -f2`
container_gw=`ip addr show docker0 | grep &quot;inet\b&quot; | awk '{print $2}' | cut -d / -f1`

bridge_name=&quot;veth_$container_minid&quot;
container_ip=$bind_ip/$container_netmask
pid=`docker inspect -f '{{.State.Pid}}' $container_name 2&gt; /dev/null`
if [ ! $pid ];then
    echo &quot;获取容器$container_name的id失败&quot;
    exit 4
fi

if [ ! -d /var/run/netns ];then
    mkdir -p /var/run/netns
fi

ln -sf /proc/$pid/ns/net /var/run/netns/$pid

ip link add $bridge_name type veth peer name X
brctl addif docker0 $bridge_name
ip link set $bridge_name up
ip link set X netns $pid
ip netns exec $pid ip link set dev X name eth0
ip netns exec $pid ip link set eth0 up
ip netns exec $pid ip addr add $container_ip dev eth0
ip netns exec $pid ip route add default via $container_gw
</code></pre>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Docker/docker-container-use-static-IP.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Python实现矩阵加法运算]]></title>
      <link>http://yaxin-cn.github.io/Python/matrix-addition-in-python.html</link>
      <guid>http://yaxin-cn.github.io/Python/matrix-addition-in-python.html</guid>
      <pubDate>Fri, 07 Nov 2014 10:04:06 GMT</pubDate>
      <description>
      <![CDATA[<p>写一个数据分析的程序，中间要处理一个2x3矩阵的相加，遂写出了下面的代码</p>
<pre><code class="language-python">def add(x, y):
    return x + y


def two_matrix_add(x, y):
 ]]>
      </description>
      <content:encoded><![CDATA[<p>写一个数据分析的程序，中间要处理一个2x3矩阵的相加，遂写出了下面的代码</p>
<pre><code class="language-python">def add(x, y):
    return x + y


def two_matrix_add(x, y):
    result = []
    for i in xrange(len(x)):
        result.append(tuple(map(lambda t: reduce(add, t), zip(x[i], y[i]))))
    return tuple(result)


def matrix_add(matrix_list):
    return reduce(two_matrix_add, matrix_list)
</code></pre>
<p>下面测试一下：</p>
<pre><code class="language-python">&gt;&gt;&gt; matrix_1 = [
...     [0, 1, 2, 3],
...     [4, 5, 6, 7],
...     [8, 9, 10, 11]
... ]
&gt;&gt;&gt; matrix_2 = [
...     [128, 204, 125, 66],
...     [230, 222, 186, 220],
...     [110, 86, 176, 249]
... ]
&gt;&gt;&gt; matrix_3 = [
...     [189, 138, 188, 113],
...     [214, 85, 180, 217],
...     [126, 195, 203, 207]
... ]
&gt;&gt;&gt; matrix_add([matrix_1, matrix_2])
((128, 205, 127, 69), (234, 227, 192, 227), (118, 95, 186, 260))
&gt;&gt;&gt; matrix_add([matrix_1, matrix_2, matrix_3])
((317, 343, 315, 182), (448, 312, 372, 444), (244, 290, 389, 467))
</code></pre>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Python/matrix-addition-in-python.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[更改ubuntu语系和时区]]></title>
      <link>http://yaxin-cn.github.io/Linux/change-locale-and-timezone-of-ubuntu.html</link>
      <guid>http://yaxin-cn.github.io/Linux/change-locale-and-timezone-of-ubuntu.html</guid>
      <pubDate>Tue, 04 Nov 2014 07:59:29 GMT</pubDate>
      <description>
      <![CDATA[<h2>一、修改时区</h2>
<h3>1. 交互式修改</h3>
<p>ubuntu提供了一个交互式的选择时区的命令<code>dpkg-reconfigure tzdata</code>，直接在命令行中输入此命令，然后选择自己的时区即可</p>
<h3>2. 直接修改</h3]]>
      </description>
      <content:encoded><![CDATA[<h2>一、修改时区</h2>
<h3>1. 交互式修改</h3>
<p>ubuntu提供了一个交互式的选择时区的命令<code>dpkg-reconfigure tzdata</code>，直接在命令行中输入此命令，然后选择自己的时区即可</p>
<h3>2. 直接修改</h3>
<p>另外一种方法相对简单，即直接复制相应的时区文件覆盖当前系统的时区文件</p>
<pre><code class="language-bash">[yaxin@ubox:~]$ cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
[yaxin@ubox:~]$ date
Tue Nov  4 16:18:55 CST 2014
</code></pre>
<p>修改是立即生效的。</p>
<h2>二、修改语系</h2>
<p>首先你需要使用<code>locale-gen</code>编译locale定义文件，直接在命令后面指定要编译的locale（可以查看/usr/share/i18n/SUPPORTED来获取locale的格式）</p>
<pre><code class="language-bash">[yaxin@ubox:~]$ sudo locale-gen zh_CN.UTF-8 en_US.UTF-8
Generating locales...
  en_US.UTF-8... up-to-date
  zh_CN.UTF-8... up-to-date
Generation complete.
[yaxin@ubox:~]$ echo 'LANG=&quot;en_US.UTF-8&quot;' &gt; /etc/default/locale
</code></pre>
<p>语系的修改并不是立即生效的，你需要重启机器才能生效。</p>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Linux/change-locale-and-timezone-of-ubuntu.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[PHP中的DateTime类]]></title>
      <link>http://yaxin-cn.github.io/PHP/class-datetime-in-php.html</link>
      <guid>http://yaxin-cn.github.io/PHP/class-datetime-in-php.html</guid>
      <pubDate>Fri, 22 Aug 2014 04:13:30 GMT</pubDate>
      <description>
      <![CDATA[<p><a href="http://php.net/manual/zh/class.datetime.php" target="_blank" rel="external"><code>DataTime</code></a>类跟<code>date()</code>,<code]]>
      </description>
      <content:encoded><![CDATA[<p><a href="http://php.net/manual/zh/class.datetime.php" target="_blank" rel="external"><code>DataTime</code></a>类跟<code>date()</code>,<code>strtotime()</code>,<code>gmdate()</code>等函数有相同的作用，都是用来处理日期和时间的，但<code>DateTime</code>类更加直观、方便, 所以在PHP5.2.0以后推荐使用<code>DateTime</code>类而不是相应的函数。</p>
<p>下面来看一下<code>DateTime</code>类的用法。</p>
<h2>1. 获取当前系统时间并打印</h2>
<pre><code class="language-php">&lt;?php
$date = new DateTime();
echo $date-&gt;format('Y-m-d H:i:s');
?&gt;
</code></pre>
<blockquote>
<p>执行结果为：2014-08-25 12:58:29</p>
</blockquote>
<h2>2. 获取特定时间并打印</h2>
<pre><code class="language-php">&lt;?php
$date = new DateTime('2014-05-04');
echo $date-&gt;format('Y-m-d H:i:s');
echo &quot;\n&quot;;
$date2 = new DateTime('tomorrow');
echo $date2-&gt;format('Y-m-d H:i:s');
echo &quot;\n&quot;;
$date2 = new DateTime('+2 days');
echo $date2-&gt;format('Y-m-d H:i:s');
?&gt;
</code></pre>
<blockquote>
<p>执行结果为：
2014-05-04 00:00:00
2014-08-26 00:00:00
2014-08-27 13:13:34</p>
</blockquote>
<p>或则通过DateTime的其他方法</p>
<pre><code class="language-php">&lt;?php
$date = new DateTime();
// add方法
$date-&gt;add(new DateInterval('P1D'));
echo $date-&gt;format('Y-m-d H:i:s');
echo &quot;\n&quot;;
// modify方法
$date-&gt;modify('+1 day');
echo $date-&gt;format('Y-m-d H:i:s');
echo &quot;\n&quot;;
// setDate方法
$date-&gt;setDate('1989-11-10');
echo $date-&gt;format('Y-m-d H:i:s');
echo &quot;\n&quot;;
// setTime方法
$date-&gt;setTime('11:10:10');
echo $date-&gt;format('Y-m-d H:i:s');
echo &quot;\n&quot;;
?&gt;
</code></pre>
<blockquote>
<p>执行结果分别为：
2014-08-26 15:02:57
2014-08-27 15:02:57
1989-11-10 15:02:57
1989-11-10 11:10:10</p>
</blockquote>
<h2>3. unix时间戳的转换</h2>
<h3>获取当前时间的时间戳</h3>
<pre><code class="language-php">&lt;?php
$date = new DateTime();
echo $date-&gt;format('U');
echo &quot;\n&quot;;
?&gt;
</code></pre>
<blockquote>
<p>执行结果为：1408950651</p>
</blockquote>
<p>或者</p>
<pre><code class="language-php">&lt;?php
$date = new DateTime();
echo $date-&gt;getTimestamp();
echo &quot;\n&quot;;
?&gt;
</code></pre>
<h3>将时间戳转换为可读时间</h3>
<pre><code class="language-php">&lt;?php
$date = new DateTime('@1408950651');
$date-&gt;setTimezone(new DateTimeZone('Asia/Shanghai'));
echo $date-&gt;format('Y-m-d H:i:s');
echo &quot;\n&quot;;
?&gt;
</code></pre>
<blockquote>
<p>执行结果为：2014-08-25 15:10:51</p>
</blockquote>
<p>或者</p>
<pre><code class="language-php">&lt;?php
$date = new DateTime();
$date-&gt;setTimestamp(1408950651);
echo $date-&gt;format('Y-m-d H:i:s');
echo &quot;\n&quot;;
?&gt;
</code></pre>
<h2>4. 日期的比较</h2>
<h3>日期大小比较</h3>
<pre><code class="language-php">&lt;?php
$date1 = new DateTime();
$date2 = new DateTime('2014-09-15');

if($date1 &lt; $date2) {
    echo $date2-&gt;format('Y-m-d H:i:s') . ' is in the future';
}
?&gt;
</code></pre>
<h3>日期间隔</h3>
<pre><code class="language-php">&lt;?php
$date1 = new DateTime();
$date2 = new DateTime('2014-09-15');

$diff = $date1-&gt;diff($date2);
print_r($diff);
?&gt;
</code></pre>
<blockquote>
<p>执行结果为:
DateInterval Object
(
[y] =&gt; 0
[m] =&gt; 0
[d] =&gt; 20
[h] =&gt; 7
[i] =&gt; 35
[s] =&gt; 50
[weekday] =&gt; 0
[weekday_behavior] =&gt; 0
[first_last_day_of] =&gt; 0
[invert] =&gt; 0
[days] =&gt; 20
[special_type] =&gt; 0
[special_amount] =&gt; 0
[have_weekday_relative] =&gt; 0
[have_special_relative] =&gt; 0
)</p>
</blockquote>
<p>将返回的对象格式化输出</p>
<pre><code class="language-php">&lt;?php
$date1 = new DateTime();
$date2 = new DateTime('2014-09-15');

$diff = $date1-&gt;diff($date2);
echo $diff-&gt;format(&quot;The future will come in %Y years %m months and %d days&quot;);
?&gt;
</code></pre>
<blockquote>
<p>输出结果为：The future will come in 00 years 0 months and 20 days</p>
</blockquote>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/PHP/class-datetime-in-php.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[解决ssh到ubuntu server卡顿]]></title>
      <link>http://yaxin-cn.github.io/Linux/solve-ssh-slow-to-ubuntu.html</link>
      <guid>http://yaxin-cn.github.io/Linux/solve-ssh-slow-to-ubuntu.html</guid>
      <pubDate>Tue, 08 Jul 2014 12:15:34 GMT</pubDate>
      <description>
      <![CDATA[<p>ssh到ubuntu14.04卡的要死，google一下无非是修改<strong>sshd_config</strong>文件中的<code>GSSAPIAuthentication</code>和<code>UseDNS</code>选项，但依然无济于事。</p>
<p>]]>
      </description>
      <content:encoded><![CDATA[<p>ssh到ubuntu14.04卡的要死，google一下无非是修改<strong>sshd_config</strong>文件中的<code>GSSAPIAuthentication</code>和<code>UseDNS</code>选项，但依然无济于事。</p>
<p>使用<code>-v</code>参数（可以输出ssh详细过程）ssh发现卡顿是发生在输入密码之后的</p>
<pre><code class="language-bash">yaxin@192.168.1.1's password:
debug1: Authentication succeeded (password).
debug1: channel 0: new [client-session]
debug1: Requesting no-more-sessions@openssh.com
debug1: Entering interactive session. # 卡一段时间
</code></pre>
<p>这说明进入交互式终端的时候卡了，再来看登录后</p>
<pre><code class="language-bash">Welcome to Ubuntu 14.04 LTS (GNU/Linux 3.13.0-24-generic x86_64)
......
62 packages can be updated.
43 updates are security updates.

Last login: Tue Jul  8 20:29:20 2014 from 192.168.1.5
</code></pre>
<p>上面的内容在其它版本中为<code>/etc/motd</code>中的内容，但ubuntu是动态生成该内容，生成脚本在<code>/etc/update-motd.d</code>目录下，查看脚本可以是联网检测系统更新等情况。呵呵，如何禁用。</p>
<p>修改<code>/etc/pam.d/sshd</code>和<code>/etc/pam.d/login</code>文件中的有<strong>pam_motd.so</strong>的行注释掉</p>
<pre><code class="language-bash">#session    optional     pam_motd.so  motd=/run/motd.dynamic noupdate
#session    optional     pam_motd.so # [1]
</code></pre>
<p>再次ssh，这次没有了上面的update等信息了，但ssh也不卡顿了。</p>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Linux/solve-ssh-slow-to-ubuntu.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Docker中搭建开发环境1]]></title>
      <link>http://yaxin-cn.github.io/Docker/setup-development-enviroment-in-docker-1.html</link>
      <guid>http://yaxin-cn.github.io/Docker/setup-development-enviroment-in-docker-1.html</guid>
      <pubDate>Fri, 04 Jul 2014 05:06:58 GMT</pubDate>
      <description>
      <![CDATA[<p>由于docker有很好的隔离性，所以开发使用最适合不过。windows下配合**<a href="https://github.com/boot2docker/windows-installer/releases" target="_blank" rel="external]]>
      </description>
      <content:encoded><![CDATA[<p>由于docker有很好的隔离性，所以开发使用最适合不过。windows下配合**<a href="https://github.com/boot2docker/windows-installer/releases" target="_blank" rel="external">boot2docker</a>**轻松击败重量级虚拟机。</p>
<p>由于是开发环境，我们首先需要将docker container开启ssh服务，以便随时登录到上面查看修改配置，之后再去搭建真正的开发环境。所以我们可以先创建一个开启了ssh服务的image来作为base image，然后在它的基础之上搭建不通的开发环境。</p>
<p>创建镜像需要使用到Dockerfile，Dockerfile的具体语法可以到<a href="http://docker-docs.qiniudn.com/reference/builder/" title="Dockerfile文档" target="_blank" rel="external">官网</a>去查看，这里不详细介绍。</p>
<p>先上<em>Dockerfile</em>内容：</p>
<pre><code class="language-bash"># sshd
# VERSION 1.0.0

FROM ubuntu:14.04
MAINTAINER yaxin &lt;yaxin.me@gmail.com&gt;

# make sure the package repository is up to date
RUN sed -i &quot;s/archive.ubuntu.com/mirrors.aliyun.com/g&quot; /etc/apt/sources.list
RUN apt-get update
RUN apt-get install -y openssh-server
# Config ssh server
RUN mkdir -p /var/run/sshd
RUN sed -i &quot;s/^PermitRootLogin without-password/PermitRootLogin yes/g&quot; /etc/ssh/sshd_config
RUN sed -i &quot;s/^#GSSAPIAuthentication no/GSSAPIAuthentication no/g&quot; /etc/ssh/sshd_config
RUN echo &quot;UseDNS no&quot; &gt;&gt; /etc/ssh/sshd_config
RUN echo 'root:root' | chpasswd

EXPOSE 22
CMD [&quot;/usr/sbin/sshd&quot;, &quot;-D&quot;]
</code></pre>
<p>新建文件夹并将上面的代码保存为以<strong>Dockerfile</strong>命名的文本文件。</p>
<p>然后执行</p>
<pre><code class="language-bash">[yaxin@ubox sshd]$ls
Dockerfile
[yaxin@ubox sshd]$docker build -t ubuntu:base .
</code></pre>
<p>来创建镜像。下面来稍微解释一下Dockerfile的内容</p>
<h3>FROM</h3>
<p>必须是Dockerfile的第一句，之后的操作都是在这个镜像之上进行的。如果你没有，那要先下载，<code>docker pull ubuntu</code>，如果无法下载，翻墙吧。如果你有国外vps，那么你可以在vps上<code>docker pull ubuntu</code>下载该镜像然后<code>docker save ubuntu:14.04 | bzip2 -9 -c &gt; ubuntu_14.04.tar.bz2</code>，然后下载ubuntu_14.04.tar.bz2到本机，运行<code>bzip2 -d -c &lt; ubuntu_14.04.tar.bz2 | docker load</code>导入镜像，我就是这么干的。</p>
<h3>RUN</h3>
<p>执行shell命令。</p>
<h3>ADD</h3>
<p>将外部文件导入到镜像中。</p>
<h3>EXPOSE</h3>
<p>将22端口‘暴漏’出来，以便在外部访问该端口。没有的话，将无法从外部（非运行docker的主机）ssh。</p>
<h3>CMD</h3>
<p>跟<code>RUN</code>一样，也是执行shell命令，不同的是<code>RUN</code>是在创建镜像的时候执行，而<code>CMD</code>是在每次执行<code>docker run image</code>的时候执行。</p>
<p>build完镜像后，我们执行<code>docker images</code>会发现多了一个镜像</p>
<pre><code class="language-bash">[yaxin@ubox sshd]$docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
ubuntu              base                615ea4d4c1e0        2 weeks ago         396.4 MB
ubuntu              14.04               ad892dd21d60        4 weeks ago         275.5 MB
</code></pre>
<p>然后启动镜像</p>
<pre><code class="language-bash">[yaxin@ubox sshd]$docker run -d -P --name=&quot;sshd&quot; ubuntu:base
c2518b7cf9289567c258171e93462bdb7fffe873bf2251d7086cd97e03e3ee57
[yaxin@ubox sshd]$docker ps
CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                   NAMES
c2518b7cf928        ubuntu:base         /usr/sbin/sshd -D      4 seconds ago       Up 3 seconds        0.0.0.0:49153-&gt;22/tcp   sshd
</code></pre>
<p>然后ssh 49153端口</p>
<pre><code class="language-bash">[yaxin@ubox sshd]$ssh root@localhost -p 49153
The authenticity of host '[localhost]:49153 ([::1]:49153)' can't be established.
ECDSA key fingerprint is c4:a5:26:07:8b:72:97:40:f2:42:fa:35:9a:7c:d0:79.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '[localhost]:49153' (ECDSA) to the list of known hosts.
root@localhost's password: 
Welcome to Ubuntu 14.04 LTS (GNU/Linux 3.2.0-58-generic x86_64)

 * Documentation:  https://help.ubuntu.com/

The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

root@c2518b7cf928:~# 
</code></pre>
<p>自此，一个装有ssh服务的可以运行的base image就创建成功了。</p>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Docker/setup-development-enviroment-in-docker-1.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[icmp包检验和计算方法及python实现]]></title>
      <link>http://yaxin-cn.github.io/Python/icmp-packet-checksum-with-python.html</link>
      <guid>http://yaxin-cn.github.io/Python/icmp-packet-checksum-with-python.html</guid>
      <pubDate>Fri, 30 May 2014 06:24:01 GMT</pubDate>
      <description>
      <![CDATA[<p>发送icmp包时，需要计算icmp包的校验和，与ip包不同的是，icmp包需要连通头部信息加数据本身一起进行校验（ip包只需要校验头部信息）</p>
<p>校验方法如下：</p>
<ol>
<li>把校验和字段置为0</li>
<li>将icmp包（包括header和dat]]>
      </description>
      <content:encoded><![CDATA[<p>发送icmp包时，需要计算icmp包的校验和，与ip包不同的是，icmp包需要连通头部信息加数据本身一起进行校验（ip包只需要校验头部信息）</p>
<p>校验方法如下：</p>
<ol>
<li>把校验和字段置为0</li>
<li>将icmp包（包括header和data）以16bit（2个字节）为一组，并将所有组相加（二进制求和）</li>
<li>若高16bit不为0，则将高16bit与低16bit反复相加，直到高16bit的值为0，从而获得一个只有16bit长度的值</li>
<li>将此16bit值进行按位求反操作，将所得值替换到校验和字段</li>
</ol>
<p><strong>注意</strong>: 第四步中的<em>按位求反</em>值C语言的的<em>按位求反</em>（即~操作符），不是python中的<em>按位求反</em></p>
<p>例如下图中的icmp包：</p>
<p><img src="//cube2x-blog.qiniudn.com/blog-img/icmp_data.png" alt="icmp抓包截图"></p>
<p>其中icmp包的内容为：</p>
<blockquote>
<p>08 00 F9 CE 7C E2 01 00 20 28 20 52 64 77 6A 6D 58 67 65 42 5A 2A 61 64 52 41 44 78 75 40 35 28 6F 76 20 43 56 76 59 20 4E 4F 64 20 20 6B 75 64 40 72 31 4A 50 20 20 33 67 20 2B 31 2A 51 20 52 70</p>
</blockquote>
<p>校验字段为<strong>F9 CE</strong></p>
<p>将校验字段置为0，然后以16bit为一组将全部字段二进制相加，即：</p>
<p>0800 + 0000 + 7CE2 + 0100 + 2028 + 2052 + 6477 + 6A6D + 5867 + 6542 + 5A2A + 6164 + 5241 + 4478 + 7540 + 3528 + 6F76 + 2043 + 5676 + 5920 + 4E4F + 6420 + 206B + 7564 + 4072 + 314A + 5020 + 2033 + 6720 + 2B31 + 2A51 + 2052 + 70 = 930fd</p>
<p><strong>注意该数据的长度并不是16bit的整数倍，计算方式一样，只不过将最后8bit直接与之前相加</strong></p>
<p>然后将结果的高16bit和低16bit继续相加：</p>
<p>0009 + 30fd = 3106</p>
<p>然后对结果（3106）进行c语言的<em>按位求反</em>操作（C语言的按位求反）：</p>
<p>~3106 =&gt; CEF9</p>
<p><em><em>C语言的</em>按位求反</em>是让操作数的二进制位上的1变为0，0变为1， 而python的<em>按位求反</em>这是将操作数加一然后乘以负一（~5 == -6），两者之所以出现不同就在于操作数是否是unsigned**</p>
<p>附上最后的程序（注意一下如何将python的<em>按位求反</em>转为C语言的<em>按位求反</em>）</p>
<pre><code class="language-python">def checksum(data):
    length = len(data)
    s = 0
    n = length % 2
    # 分割数据每两比特(16bit)为一组
    for i in range(0, length - n, 2):
        s += ord(data[i]) + (ord(data[i+1]) &lt;&lt; 8)
    # 如果数据长度为基数,则将最后一位单独相加
    if n:
        s += ord(data[-1])
    # 重复将高16位与低16位相加直到高16位为0
    while (s &gt;&gt; 16):
        s = (s &amp; 0xFFFF) + (s &gt;&gt; 16)
    s = ~s &amp; 0xffff
    # 返回的是十进制整数
    return s
</code></pre>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Python/icmp-packet-checksum-with-python.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[理解Python中数值和字符串对象是不可变化的]]></title>
      <link>http://yaxin-cn.github.io/Python/understand-python-string-objects-are-immutable.html</link>
      <guid>http://yaxin-cn.github.io/Python/understand-python-string-objects-are-immutable.html</guid>
      <pubDate>Mon, 19 May 2014 13:11:32 GMT</pubDate>
      <description>
      <![CDATA[<p>在Python中数值和字符串对象是不可以改变的，但对于新手的我们很难理解，于是乎会有下面的代码:</p>
<pre><code class="language-python">x = 'Hello World'
print x
x = 'Hello Hello'
print]]>
      </description>
      <content:encoded><![CDATA[<p>在Python中数值和字符串对象是不可以改变的，但对于新手的我们很难理解，于是乎会有下面的代码:</p>
<pre><code class="language-python">x = 'Hello World'
print x
x = 'Hello Hello'
print x
</code></pre>
<p>上面的代码明显的说明了变量<code>x</code>是可以改变的。其实变量<code>x</code>的改变伴随着<code>x</code>内存地址的变化，也就是说系统重新创建了一个名为<strong>x</strong>的变量用于保存新字符串。想要证明这个需要用到Python的<code>id</code>函数。</p>
<p>id函数返回一个数字，这个数字跟该对象的分配内存地址密切相关。也可以近似认为这个数值就是该对象（变量）的所在内存地址。</p>
<blockquote>
<p>python中id函数的说明
Help on built-in function id in module <strong>builtin</strong>:</p>
<p>id(...)
id(object) -&gt; integer</p>
<p>Return the identity of an object.  This is guaranteed to be unique among
simultaneously existing objects.  (Hint: it's the object's memory address.)</p>
</blockquote>
<p>现在再来看下面的代码：</p>
<pre><code class="language-python">x = 'Hello World'
print id(x)
x = 'Hello Hello'
print id(x)
y = ['a', 'b']
print id(y)
y.append('c')
print id(y)
</code></pre>
<p>你运行结果如下：</p>
<blockquote>
<p>21908576
21906752
23032176
23032176</p>
</blockquote>
<p>可以看出前两个<code>id</code>的结果并不相同，而后面的两个（python中列表、字典对象是可变的）结果却是一样的，这说明字符串对象在python中是不可变的，即使重新对变量赋值，也只是重新生成相同变量的字符串而并不是直接改变当前的字符串变量。</p>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Python/understand-python-string-objects-are-immutable.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[docker中如何删除image（镜像）]]></title>
      <link>http://yaxin-cn.github.io/Docker/how-to-delete-a-docker-image.html</link>
      <guid>http://yaxin-cn.github.io/Docker/how-to-delete-a-docker-image.html</guid>
      <pubDate>Sat, 22 Mar 2014 07:46:29 GMT</pubDate>
      <description>
      <![CDATA[<p>docker中删除images的命令是<code>docker rmi</code>，但有时候执行此命令并不能删除images</p>
<pre><code class="language-bash">[yaxin@ubox ~]$docker images
REPOSIT]]>
      </description>
      <content:encoded><![CDATA[<p>docker中删除images的命令是<code>docker rmi</code>，但有时候执行此命令并不能删除images</p>
<pre><code class="language-bash">[yaxin@ubox ~]$docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
eg_sshd             latest              ed9c93747fe1        45 hours ago        329.8 MB
CentOS65            latest              e55a74a32125        2 days ago          360.6 MB
[yaxin@ubox ~]$docker rmi ed9c93747fe1
Untagged: ed9c93747fe16627be822ad3f7feeb8b4468200e5357877d3046aa83cc44c6af
[yaxin@ubox ~]$docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
&lt;none&gt;              &lt;none&gt;              ed9c93747fe1        45 hours ago        329.8 MB
CentOS65            latest              e55a74a32125        2 days ago          360.6 MB
</code></pre>
<p>可以看出，image并没有被删除，只是他的tag被删除了，再次执行<code>docker rmi IMAGE_ID</code>只会报错</p>
<pre><code class="language-bash">[yaxin@ubox ~]$docker rmi ed9c93747fe1
Error: image_delete: Conflict, ed9c93747fe1 wasn't deleted
2014/03/22 15:58:27 Error: failed to remove one or more images
</code></pre>
<p>查看docker的帮助会发现有两个与删除有关的命令<code>rm</code>和<code>rmi</code></p>
<blockquote>
<p>rm        Remove one or more containers<br>
rmi       Remove one or more images</p>
</blockquote>
<p>这里有两个不同的单词，<strong>images</strong>和<strong>container</strong>。其中images很好理解，跟平常使用的虚拟机的镜像一个意思，相当于一个模版，而container则是images运行时的的状态。docker对于运行过的image都保留一个状态（container），可以使用命令<code>docker ps</code>来查看正在运行的container，对于已经退出的container，则可以使用<code>docker ps -a</code>来查看。 如果你退出了一个container而忘记保存其中的数据，你可以使用<code>docker ps -a</code>来找到对应的运行过的container使用<code>docker commit</code>命令将其保存为image然后运行。</p>
<p>回到之前的问题，由于image被某个container引用（拿来运行），如果不将这个引用的container销毁（删除），那image肯定是不能被删除。</p>
<p>所以想要删除运行过的images必须首先删除它的container。继续来看刚才的例子，</p>
<pre><code class="language-bash">[yaxin@ubox ~]$docker ps -a
CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                   NAMES
117843ade696        ed9c93747fe1        /bin/sh -c /usr/sbin   46 hours ago        Up 46 hours         0.0.0.0:49153-&gt;22/tcp   test_sshd
</code></pre>
<p>可以看出<strong>ed9c93747fe1</strong>的image被<strong>117843ade696</strong>的container使用着，所以必须首先删除该container</p>
<pre><code class="language-bash">[yaxin@ubox ~]$docker rm 117843ade696
Error: container_delete: Impossible to remove a running container, please stop it first
2014/03/22 16:36:44 Error: failed to remove one or more containers
</code></pre>
<p>出现错误，这是因为该container正在运行中(运行<code>docker ps</code>查看)，先将其关闭</p>
<pre><code class="language-bash">[yaxin@ubox ~]$docker stop 117843ade696
117843ade696
</code></pre>
<pre><code class="language-bash">[yaxin@ubox ~]$docker rm 117843ade696
117843ade696
[yaxin@ubox ~]$docker rmi ed9c93747fe1
Deleted: ed9c93747fe16627be822ad3f7feeb8b4468200e5357877d3046aa83cc44c6af
Deleted: c8a0c19429daf73074040a14e527ad5734e70363c644f18c6815388b63eedc9b
Deleted: 95dba4c468f0e53e5f1e5d76b8581d6740aab9f59141f783f8e263ccd7cf2a8e
Deleted: c25dc743e40af6858c34375d450851bd606a70ace5d04e231a7fcc6d2ea23cc1
Deleted: 20562f5714a5ce764845119399ef75e652e23135cd5c54265ff8218b61ccbd33
Deleted: c8af1dc23af7a7aea0c25ba9b28bdee68caa8866f056e4f2aa2a5fa1bcb12693
Deleted: 38fdb2c5432e08ec6121f8dbb17e1fde17d5db4c1f149a9b702785dbf7b0f3be
Deleted: 79ca14274c80ac1df1333b89b2a41c0e0e3b91cd1b267b31bef852ceab3b2044
[yaxin@ubox ~]$docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
CentOS65            latest              e55a74a32125        2 days ago          360.6 MB
</code></pre>
<p>可以看出，image已经被删除。</p>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Docker/how-to-delete-a-docker-image.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[shell实现输入密码显示星号]]></title>
      <link>http://yaxin-cn.github.io/Linux/replace-password-with-stars-under-shell.html</link>
      <guid>http://yaxin-cn.github.io/Linux/replace-password-with-stars-under-shell.html</guid>
      <pubDate>Sat, 07 Sep 2013 07:02:48 GMT</pubDate>
      <description>
      <![CDATA[<p>shell脚本可以使用read -s来默认禁止回显输入字符，这样做一定程度上可以保证安全性。但这并不是一个好的交互，因为对于输入密码并不能知道已经输入了多少个字符。而使用*（星号）来代替输入的字符是一个很不错的想法，即保证安全又有好的交互性。</p>
<p>程序的实现</p]]>
      </description>
      <content:encoded><![CDATA[<p>shell脚本可以使用read -s来默认禁止回显输入字符，这样做一定程度上可以保证安全性。但这并不是一个好的交互，因为对于输入密码并不能知道已经输入了多少个字符。而使用*（星号）来代替输入的字符是一个很不错的想法，即保证安全又有好的交互性。</p>
<p>程序的实现</p>
<p>首先要实现不显示输入字符，这个可以使用命令stty来实现</p>
<pre><code class="language-bash">stty cbreak -echo
dd if=/dev/tty bs=1 count=1 2&gt;/dev/null
stty -cbreak echo
</code></pre>
<p>运行上面的命令（放在脚本中），可以发现输入一个字符并不会在屏幕上显示出来，这是因为<code>stty -echo</code>会禁止回显，而<code>dd if=/dev/tty bs=1 count=1 2&gt;/dev/null</code>则是获取刚刚输入的字符，如果将上面的命令放在$()中运行，并将其赋值给变量，打印会发现就是刚刚输入的字符。</p>
<p>由于上面的命令只是接收一个字符，要多个字符的话需要使用while语句来实现，然后通过判断输入的字符是否为回车键来实现结束输入。</p>
<pre><code class="language-bash">while : ;do
    char=`
        stty cbreak -echo
        dd if=/dev/tty bs=1 count=1 2&gt;/dev/null
        stty -cbreak echo
    `
    if [ &quot;$char&quot; =  &quot;&quot; ];then
        break
    fi
    password=&quot;$password$char&quot;
done
</code></pre>
<p>然后我们来实现输出为星号。这个很简单，上面的程序在整个过程中不会输出任何字符，要实现输出只需要在每次while循环的结束输出一个*即可。</p>
<pre><code class="language-bash">while : ;do
    char=`
        stty cbreak -echo
        dd if=/dev/tty bs=1 count=1 2&gt;/dev/null
        stty -cbreak echo
    `
    if [ &quot;$char&quot; =  &quot;&quot; ];then
        break
    fi
    password=&quot;$password$char&quot;
    echo -n &quot;*&quot;
done
</code></pre>
<p>OK，全部实现完毕，密码存在password变量中。</p>
<p>错误解决</p>
<p>但在运行中会发现，按删除（backspace）不会减少个数，反而增加了。直接运行read命令，然后按backspace键，会发现输出了“^H”，这是因为backspace并未绑定为删除功能，需要在脚本中添加<code>stty erase &quot;^H&quot;</code>来解决这一问题。但此时问题还是存在，原因在于backspace也是一个按键，而while中的判断并未判断按键为backspace的情况，因而程序会运行到输出一行。解决的方法就是在while中判断backspace按键并进行相应的操作。</p>
<p>首先是判断backspace按键，获取backspace按键的方法有两种：第一种是使用子shell输出backspace的转义字符即<code>$(echo -ne &quot;\b&quot;)</code>、第二种是利用vim，先按ctrl+v然后再backspace，就会输出backspace的标志。</p>
<p>然后是删除之前的一个字符，这里使用shell的ANSI控制码，首先将光标前移一个字符<code>printf &quot;33[1D&quot;</code>，然后删除光标之后的字符<code>printf &quot;33[K&quot;</code>，当然，还要将最后一个字符从password变量中移除。</p>
<p>最后完整的程序应该是：</p>
<pre><code class="language-bash">x=0
while : ;do
    char=`
        stty cbreak -echo
        dd if=/dev/tty bs=1 count=1 2&gt;/dev/null
        stty -cbreak echo
    `
    if [ &quot;$char&quot; =  &quot;&quot; ];then
        break
    fi
    if [[ &quot;$ret&quot; == $(echo -ne '\b') ]];then
        if [ $x -eq 0 ];then
            continue
        fi
        password=&quot;${password%?}&quot;
        printf &quot;33[1D&quot;
        printf &quot;33[K&quot;
        let x--
        continue
    fi
    password=&quot;$password$char&quot;
    echo -n &quot;*&quot;
    let x++
done
</code></pre>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Linux/replace-password-with-stars-under-shell.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[未知元素高度情况下使其垂直居中方案]]></title>
      <link>http://yaxin-cn.github.io/front-end/make-element-vertical-center-with-css.html</link>
      <guid>http://yaxin-cn.github.io/front-end/make-element-vertical-center-with-css.html</guid>
      <pubDate>Sun, 23 Dec 2012 02:06:56 GMT</pubDate>
      <description>
      <![CDATA[<p>一直以来都是使用<a href="http://xinmu.me/blog" target="_blank" rel="external">xinmu.me/blog</a>作为博客的首页，而<a href="http://xinmu.me" target="_blank"]]>
      </description>
      <content:encoded><![CDATA[<p>一直以来都是使用<a href="http://xinmu.me/blog" target="_blank" rel="external">xinmu.me/blog</a>作为博客的首页，而<a href="http://xinmu.me" target="_blank" rel="external">xinmu.me</a>则一直荒废着。今天忽然想起了它，便想着先放一个链接上去，一个链接还是居中的好（浏览器正中央）。上网搜了各种方法，都需要知道元素的高度才可以，遂上SegmentFault（一个很好的地方）提问，得到了大神神飞的帮助，解决了问题，下面只是将解决办法复制、粘贴一下，原问题在此<a href="http://segmentfault.com/q/1010000000153017" target="_blank" rel="external">http://segmentfault.com/q/1010000000153017</a></p>
<pre><code class="language-html">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
&lt;title&gt;只是文字的水平和垂直居中&lt;/title&gt;
&lt;style&gt;
html,body{width: 100%;height: 100%;margin: 0;padding: 0}
body{background-color: green;display: table;}
p{line-height: 1.6;text-align: center;padding: 0;margin: 0;display: table-cell;vertical-align: middle;}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;wording&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/front-end/make-element-vertical-center-with-css.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Linux下查看网卡MAC地址]]></title>
      <link>http://yaxin-cn.github.io/Linux/check-mac-address-under-linux.html</link>
      <guid>http://yaxin-cn.github.io/Linux/check-mac-address-under-linux.html</guid>
      <pubDate>Tue, 18 Dec 2012 01:56:51 GMT</pubDate>
      <description>
      <![CDATA[<h2>方法一：使用ifconfig命令</h2>
<p>直接在命令行中ifconfig，即可看到所有已连接网线（已经激活的网卡）的网卡信息</p>
<pre><code class="language-bash">[yaxin@oishi ~]$ifconfig
eth0   ]]>
      </description>
      <content:encoded><![CDATA[<h2>方法一：使用ifconfig命令</h2>
<p>直接在命令行中ifconfig，即可看到所有已连接网线（已经激活的网卡）的网卡信息</p>
<pre><code class="language-bash">[yaxin@oishi ~]$ifconfig
eth0      Link encap:Ethernet  HWaddr 00:50:56:AC:57:30  
          inet addr:10.10.8.110  Bcast:10.10.8.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:11645825 errors:0 dropped:0 overruns:0 frame:0
          TX packets:9430946 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:2446979632 (2.2 GiB)  TX bytes:1937455163 (1.8 GiB)

eth0:1    Link encap:Ethernet  HWaddr 00:50:56:AC:57:30  
          inet addr:10.10.8.10  Bcast:10.10.8.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:12722 errors:0 dropped:0 overruns:0 frame:0
          TX packets:12722 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:710416 (693.7 KiB)  TX bytes:710416 (693.7 KiB)
</code></pre>
<h2>方法二：使用/sys目录</h2>
<p>使用cd命令进入/sys/class/net/目录，然后ls查看目录下的文件，你会惊奇的发现里面有以网卡名命名的文件夹，</p>
<pre><code class="language-bash">[yaxin@oishi net]$ls
eth0  lo
</code></pre>
<p>这些文件夹便是你电脑中所有网卡，包括激活和未激活的（lo是本地回环网卡，并不是真实的网卡），cd进入任何一个目录（不是lo），然后，该网卡的所有信息便包含在里面(包括网卡的MAC地址信息)。</p>
<pre><code class="language-bash">[yaxin@oishi net]$ls
eth0  lo
[yaxin@oishi net]$cd eth0/
[yaxin@oishi eth0]$ls
addr_assign_type  broadcast  dev_id   features  ifindex    mtu        queues      subsystem     uevent
address           carrier    dormant  flags     iflink     operstate  speed       tx_queue_len
addr_len          device     duplex   ifalias   link_mode  power      statistics  type
[yaxin@oishi eth0]$
</code></pre>
<p>然后使用cat命令查看一下address文件，显示的便是该网卡的MAC地址</p>
<pre><code class="language-bash">[yaxin@oishi eth0]$cat address 
00:50:56:ac:57:30
[yaxin@oishi eth0]$
</code></pre>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Linux/check-mac-address-under-linux.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Linux下文件的打包与解压缩命令]]></title>
      <link>http://yaxin-cn.github.io/Linux/file-compress-cmd-under-linux.html</link>
      <guid>http://yaxin-cn.github.io/Linux/file-compress-cmd-under-linux.html</guid>
      <pubDate>Sun, 16 Dec 2012 00:52:16 GMT</pubDate>
      <description>
      <![CDATA[<p>打包与解压缩命令属于Linux下最常用的命令之一。打包是指将一大堆文件或文件夹变成一个文件，压缩则是将一个大的文件通过一些压缩算法变成一个小文件。这跟Windows下使用WinRAR的打包不通，因为WinRAR打包后的文件也进行了压缩。下面就给出解压缩与打包的命令。</p>]]>
      </description>
      <content:encoded><![CDATA[<p>打包与解压缩命令属于Linux下最常用的命令之一。打包是指将一大堆文件或文件夹变成一个文件，压缩则是将一个大的文件通过一些压缩算法变成一个小文件。这跟Windows下使用WinRAR的打包不通，因为WinRAR打包后的文件也进行了压缩。下面就给出解压缩与打包的命令。</p>
<h2>一、基础篇</h2>
<p>我将本文分为两个部分：基础篇和提升篇。这部分是基础篇，主要介绍一些常用的打包和解压缩命令。学会使用这些命令，足够应付日常使用了。</p>
<h3>1. 打包、压缩命令</h3>
<p>首先给出命令：</p>
<blockquote>
<p>tar.gz格式:tar zcvf FileName.tar.gz DirName
tar.bz2格式:tar jcvf FileName.tar.bz2 DirName
zip格式:zip FileName.zip DirName</p>
</blockquote>
<p>一般来说，打包要伴随着压缩，所以我这里只是给出了打包压缩一体命令，并未将打包和压缩命令分开。上面命令中“DirName”为你要打包的文件夹，“FileName.**”为打包压缩后的文件名。在Linux下，常见的压缩包格式为tar.gz、tar.bz2和zip，所以这里不再给出rar格式的打包命令。</p>
<h3>2. 解压缩命令</h3>
<p>同样先给出命令：</p>
<blockquote>
<p>tar.gz格式:tar zxvf FileName.tar.gz
tar.bz2格式:tar jxvf FileName.tar.bz2
zip格式:unzip FileName.zip</p>
</blockquote>
<p>其中“FileName.*”为你需要解包的文件。</p>
<p>如果您只是想会解包打包，那么您可以就此停下来了，因为下面的都是上面命令的分析和补充。</p>
<h2>二、提升篇</h2>
<p>在Linux下打包和压缩命令是两个概念，各自的命令也不同，你可以只打包而不压缩或则只压缩而不打包。下面我们来看一下linux中的打包和压缩格式：</p>
<blockquote>
<p>.tar打包格式：tar程序打包的数据，并没有压缩过
.Z格式：compress程序压缩的文件
.gz压缩格式：gzip程序压缩的文件
.bz2压缩格式：bzip2程序压缩的文件
.tar.gz打包压缩：tar程序打包的文件，其中并且经过 gzip 的压缩
.tar.bz2打包压缩：tar程序打包的文件，其中并且经过 bzip2 的压缩</p>
</blockquote>
<p>在这些格式中，.Z（compress程序压缩的文件）已经几乎不见了，所以这里不再搭理。</p>
<h3>1.打包</h3>
<p>在Linux中，你会经常看到tar.gz或tar.bz2格式的源码包，其中的tar便是Linux下最常用的打包程序，使用tar程序打包过的文件一般称为tar包（格式为.tar）。下面我们就来看一下tar命令的基本使用方法：</p>
<p>首先给出tar命令的参数</p>
<blockquote>
<p>-c：(create)建立打包文件，搭配-v可察看打包过程中被打包的文件
-t：查看打包文件的内容含有哪些文件名
-x：解包或解压缩的功能，搭配-C（大写）可以在特定目录解开
-j：通过bzip2的进行压缩/解压缩，此时文件名正常情况下为*.tar.bz2
-z：通过gzip的进行压缩/解压缩，此时文件名正常情况下为*.tar.gz
-v：在压缩/解压缩的过程中，将正在处理的文件显示出来
-f：-f后面要立刻接要被处理的文件名，不要再加参数。也可以把-f单独写一个选项
-C：这个选项用在解压缩，后面跟目录。目的就是把文件解压缩到指定的目录
-p：保留数据的原本权限与属性，常用于备份(-c)
-P：保留绝对路径，也就是说允许备份数据中含有根目录存在之意
-r：向打包文件里面追加文件。例如用户已经打包好文件，又发现还有一个目录或是一些文件忘记打包了，这时可以使用该选项，将忘记的目录或文件追加到打包的文件中
–exclude=FILE：在压缩的过程中，不要将FILE打包
-u：更新文件。就是说，用新增的文件取代原备份文件，如果在备份文件中找不到要更新的文件，则把它追加到备份文件的最后
-N：比后面接的日期(yyyy/mm/dd)还要新的才会被打包进新建的文件中</p>
</blockquote>
<p>注意：-c, -t, -x参数不可同时出现。</p>
<p>下面来举几个例子：</p>
<p>tar -cf FileName.tar DirName：这条命令是将DirName的文件夹打成一个名为FileName.tar的包。-c是表示产生新的包，-f指定包的文件名；</p>
<p>tar -cf FileName.tar *.jpg：这条命令是将所有.jpg的文件打成一个名为FileName.tar的包；</p>
<p>tar -rf FileName.tar *.gif：这条命令是将所有.gif的文件增加到FileName.tar的包里面去。-r是表示增加文件的意思；</p>
<p>tar -uf FileName.tar logo.gif：这条命令是更新原来tar包FileName.tar中logo.gif文件，-u是表示更新文件的意思；</p>
<p>tar -tf FileName.tar：这条命令是列出FileName.tar包中所有文件，-t是列出文件的意思；</p>
<p>tar -xf FileName.tar：这条命令是解出FileName.tar包中所有文件，-x是解开的意思。</p>
<h3>2.压缩和解压</h3>
<p>①首先列出gzip程序命令压缩解压的参数：</p>
<blockquote>
<p>-c：将压缩的数据输出到屏幕上；
-d：解压缩 ；
-t：用来检验压缩文件有无错误；
-v：显示出原文件/压缩文件案的压缩比等信息；
-#：压缩等级，-1最快，但是压缩比最差。-9最慢，但是压缩比最好，预设是-6。</p>
</blockquote>
<p>当你使用gzip进行压缩时，在默认的状态下原来的文件被压缩成为。gz文件的同时源文件也就不再存在了。</p>
<p>下面给出使用gzip程序压缩解压的例子：</p>
<p>gzip FileName：此命令是压缩FileName文件；</p>
<p>gunzip FileName.gz：这条命令是解压缩FileName.gz文件;</p>
<p>gzip -d FileName.gz：此命令功能同上。</p>
<p>②接下来给出bizp2程序命令的压缩解压参数：</p>
<blockquote>
<p>-c：将压缩的过程产生的数据输出到屏幕上
-d：解压缩
-k：保留源文件，而不会删除原始的文件
-z：压缩
-v：可以显示出原文件/压缩文件的压缩比等信息
-#：与gzip同样的，都是在计算压缩比的参数，-9最佳，-1最快</p>
</blockquote>
<p>同样，在默认的状态下原来的文件被压缩成.bz2的文件，而源文件也会不存在了。但可以用-k参数保留源文件。</p>
<p>下面给出使用bzip2程序压缩解压的例子：</p>
<p>bzip2 -z FileName：这条命令是压缩FileName文件；</p>
<p>bzip2 -d FileName.bz2：解压FileName.bz2;</p>
<p>bunzip2 FileName.bz2：功能同上。</p>
<h3>3.打包和压缩解压命令合并</h3>
<p>如果将打包和压缩命令分开的话，会无故增加一步操作，从而带来很多不便，好在在执行打包（解包）命令的同时可以调用压缩（解压）的命令。</p>
<p>①tar调用gzip</p>
<p>-z：tar中使用此参数来调用gzip。
下面举例说明：</p>
<p>tar -zcvf FileName.tar.gz *.jpg：将所有的jpg格式的图片打包并压缩成FileName.tar.gz文件；</p>
<p>tar -zxvf FileName.tar.gz：将FileName.tar.gz文件解压。</p>
<p>②tar调用bzip2</p>
<p>-j：tar可以使用这个参数调用gzip。
下面举例说明：</p>
<p>tar -jcvf FileName.tar.bz2 *.jpg：将所有的jpg格式的图片打包并压缩成FileName.tar.bz2文件；</p>
<p>tar -jxvf FileName.tar.bz2：将FileName.tar.bz2文件解压。</p>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Linux/file-compress-cmd-under-linux.html#disqus_comments</comments>
    </item>
    
  </channel>
</rss>