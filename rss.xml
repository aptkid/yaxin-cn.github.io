<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[馨木]]></title>
    <link>http://yaxin-cn.github.io/</link>
    <atom:link href="/rss.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[为梦想添砖加瓦]]></description>
    <pubDate>Fri, 15 Jan 2016 10:00:41 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[Nginx下禅道的伪静态(rewrite)规则]]></title>
      <link>http://yaxin-cn.github.io/Nginx/configure-static-access-for-zentao-under-nginx.html</link>
      <guid>http://yaxin-cn.github.io/Nginx/configure-static-access-for-zentao-under-nginx.html</guid>
      <pubDate>Fri, 15 Jan 2016 02:06:52 GMT</pubDate>
      <description>
      <![CDATA[<p>搭建了一个禅道的项目管理平台，但是Nginx下并不是伪静态的，URL看着不是很舒服，上网搜索配置规则，但是没有一个可以正常使用的，于是乎自己琢磨一下。</p>
<p>先给出最终配置，有兴趣看原因的可以往下看</p>
<p><figure class="highlight">]]>
      </description>
      <content:encoded><![CDATA[<p>搭建了一个禅道的项目管理平台，但是Nginx下并不是伪静态的，URL看着不是很舒服，上网搜索配置规则，但是没有一个可以正常使用的，于是乎自己琢磨一下。</p>
<p>先给出最终配置，有兴趣看原因的可以往下看</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">server &#123;&#10;    listen 80;&#10;    root /zentao/root/path/www;&#10;    index index.php index.html index.htm;&#10;    server_name domain_name;&#10;&#10;    location / &#123;&#10;        try_files $uri /index.php$uri;&#10;    &#125;&#10;&#10;    location ~ \.php(/.+)?$ &#123;&#10;        fastcgi_pass unix:/var/run/php-fpm.sock;&#10;        fastcgi_index index.php;&#10;        include fastcgi.conf;&#10;        fastcgi_split_path_info ^(.+\.php)(/.+)$;&#10;        fastcgi_param PATH_INFO $fastcgi_path_info;&#10;    &#125;&#10;    access_log off;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>禅道给出了apache的伪静态规则，但是我尝试了半天也没有转换成可用的nginx伪静态规则，但是禅道是基于PHP的，而PHP伪静态一般基于<code>$_SERVER</code>变量中的一些变量来实现的，既然apache可以实现伪静态，那么就打印一下伪静态后的<code>$_SERVER</code>变量的值。</p>
<p>修改禅道根目录下<code>www/index.php</code>文件，在最上面修改为如下代码:</p>
<p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;"</span>;</span><br><span class="line">    print_r(<span class="variable">$_SERVER</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;/pre&gt;"</span>;</span><br><span class="line">    <span class="keyword">die</span>;</span><br></pre></td></tr></table></figure></p>
<p>然后访问http://domain/user-login-Lw==.html (此为禅道登陆url)</p>
<p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仅给出几个重要的变量</span></span><br><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">    [REDIRECT_URL] =&gt; /user-login-Lw==.html</span><br><span class="line">    [REQUEST_URI] =&gt; /user-login-Lw==.html</span><br><span class="line">    [SCRIPT_NAME] =&gt; /index.php</span><br><span class="line">    [PATH_INFO] =&gt; /user-login-Lw==.html</span><br><span class="line">    [PATH_TRANSLATED] =&gt; redirect:/index.php/user-login-Lw==.html</span><br><span class="line">    [PHP_SELF] =&gt; /index.php/user-login-Lw==.html</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>对于未配置过的nginx做相同的操作:</p>
<p><strong>未配置的nginx并不是什么都没配置，基本的还是要配置的</strong></p>
<p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="title">location</span> / &#123;</span><br><span class="line">    <span class="title">try_files</span> <span class="variable">$uri</span> /index.php;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">    <span class="comment"># With php5-fpm:</span></span><br><span class="line">    <span class="title">fastcgi_pass</span> <span class="url">unix:/var/run/php-fpm.sock</span>;</span><br><span class="line">    <span class="title">fastcgi_index</span> index.php;</span><br><span class="line">    <span class="title">include</span> fastcgi.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，这两个location还是要有的，一个是将所有的请求重定向到<code>index.php</code>，一个是解析php文件的.</p>
<p>这次，php返回的信息为</p>
<p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仅给出几个重要的变量</span></span><br><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">    [SCRIPT_NAME] =&gt; /index.php</span><br><span class="line">    [REQUEST_URI] =&gt; /user-login-Lw==.html</span><br><span class="line">    [DOCUMENT_URI] =&gt; /index.php</span><br><span class="line">    [PHP_SELF] =&gt; /index.php</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>对比一下，发现不同了吧。nginx少了<code>PATH_INFO</code>，而且<code>PHP_SELF</code>也是不一样的，至于<code>REDIRECT_URL</code>和<code>PATH_TRANSLATED</code>这些变量都是apache自己加的，禅道并不会用到。</p>
<p>回想一下禅道的配置文件<code>config/config.php</code>和<code>config/my.php</code>中有一项<code>$config-&gt;requestType</code>配置，如果配置为**<code>GET</code><strong>的话，就会禁用伪静态，而通过query string的方式，如果配置成</strong><code>PATH_INFO</code>**的话就需要nginx或apache配置伪静态规则，也就是说禅道通过解析PATH_INFO来实现伪静态的。</p>
<p>那么PATH_INFO又是什么东东，根据<a href="http://php.net/manual/zh/reserved.variables.server.php" target="_blank" rel="external">PHP官方文档</a>的解释，如果我访问http://www.example.com/php/path_info.php/some/stuff?foo=bar这个url，那个PATH_INFO就应该等于/some/stuff，也就是所<code>PATH_INFO</code>等于url中跟在真实脚本名称之后并且在查询语句（query string）之前的字符串，你可能会说，我访问的url中根本没有filename.php啊，那是因为nginx帮你添加了，记得配置中的<code>try_files $uri /index.php$uri</code>吧，这个内部跳转就是干这个事情的。</p>
<p>找到了原因就开始解决，Nginx和PHP是通过cgi协议传递数据的，可以通过nginx开启<a href="http://nginx.org/en/docs/debugging_log.html" target="_blank" rel="external">debug</a> (<a href="http://nginx.org/en/docs/debugging_log.html" target="_blank" rel="external">http://nginx.org/en/docs/debugging_log.html</a>)来查看传递nginx和php交换的数据。</p>
<p>这里不给出详细debug log了，反正开启log后发现nginx并没有传递PATH_INFO给php，于是在解析php的location中添加一行</p>
<p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="title">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">    <span class="title">fastcgi_pass</span> <span class="url">unix:/var/run/php-fpm.sock</span>;</span><br><span class="line">    <span class="title">fastcgi_index</span> index.php;</span><br><span class="line">    <span class="title">include</span> fastcgi.conf;</span><br><span class="line">    <span class="title">fastcgi_split_path_info</span><span class="regexp"> ^(.+\.php)(/.+)$</span>;</span><br><span class="line">    <span class="title">fastcgi_param</span> PATH_INFO <span class="variable">$fastcgi_path_info</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但只有这个还是不行，因为此时nginx内部变量<code>$uri</code>(就相当于PHP_SELF的值)还是*/index.php*，需要再修改一个地方</p>
<p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="title">location</span> / &#123;</span><br><span class="line">    <span class="title">try_files</span> <span class="variable">$uri</span> /index.php;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改之后php那个location就没办法被识别了，需要修改为<code>\.php(/.+)?$</code></p>
<p>最终的效果就是</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">server &#123;&#10;    listen 80;&#10;    root /zentao/root/path/www;&#10;    index index.php index.html index.htm;&#10;    server_name domain_name;&#10;&#10;    location / &#123;&#10;        try_files $uri /index.php$uri;&#10;    &#125;&#10;&#10;    location ~ \.php(/.+)?$ &#123;&#10;        fastcgi_pass unix:/var/run/php-fpm.sock;&#10;        fastcgi_index index.php;&#10;        include fastcgi.conf;&#10;        fastcgi_split_path_info ^(.+\.php)(/.+)$;&#10;        fastcgi_param PATH_INFO $fastcgi_path_info;&#10;    &#125;&#10;    access_log off;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Nginx/configure-static-access-for-zentao-under-nginx.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[python安装cffi模块的一个问题]]></title>
      <link>http://yaxin-cn.github.io/Python/issue-when-install-python-cffi.html</link>
      <guid>http://yaxin-cn.github.io/Python/issue-when-install-python-cffi.html</guid>
      <pubDate>Mon, 28 Sep 2015 05:10:45 GMT</pubDate>
      <description>
      <![CDATA[<p>系统自带的python有点老（2.6）于是下载python2.7.8的源码手动编译安装(编译参数<code>./configure --enable-shared --disable-ipv6 --prefix=/usr/local/python27 --enable-un]]>
      </description>
      <content:encoded><![CDATA[<p>系统自带的python有点老（2.6）于是下载python2.7.8的源码手动编译安装(编译参数<code>./configure --enable-shared --disable-ipv6 --prefix=/usr/local/python27 --enable-unicode=ucs4</code>)</p>
<p>安装后将系统的python替换(<code>ln -svf /usr/local/python27/bin/* /usr/bin/</code>), 安装<a href="https://bootstrap.pypa.io/ez_setup.py" target="_blank" rel="external">easy_install</a>和pip(<code>easy_install pip</code>), 之后开始安装<em>pyopenssl</em>, 但是在安装依赖<em>cffi</em>的时候报错**/usr/bin/ld: cannot find -lpython2.7**.</p>
<p>首先需要说明的是出现类似**/usr/bin/ld: cannot find -lxx**的原因主要是gcc没有找到libxx.so的文件</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ubox ~]<span class="comment"># echo '/usr/local/python27/lib' &gt; /etc/ld.so.conf.d/python-2.7.8.conf</span></span><br><span class="line">[root@ubox ~]<span class="comment"># ldconfig -v</span></span><br></pre></td></tr></table></figure></p>
<p><code>ldconfig</code>命令为重建动态链接库的缓存.然后重新执行<code>pip install cffi</code>, 但是还是报错, 使用<code>gcc -lpython2.7 --verbose</code>查看gcc查找库的路径</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ubox lib]<span class="comment"># gcc -lpython2.7 --verbose</span></span><br><span class="line">Using built-in specs.</span><br><span class="line">Target: x86_64-redhat-linux</span><br><span class="line">Configured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-languages=c,c++,objc,obj-c++,java,fortran,ada --enable-java-awt=gtk --disable-dssi --with-java-home=/usr/lib/jvm/java-<span class="number">1.5</span>.<span class="number">0</span>-gcj-<span class="number">1.5</span>.<span class="number">0.0</span>/jre --enable-libgcj-multifile --enable-java-maintainer-mode --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --disable-libjava-multilib --with-ppl --with-cloog --with-tune=generic --with-arch_32=i686 --build=x86_64-redhat-linux</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version <span class="number">4.4</span>.<span class="number">7</span> <span class="number">20120313</span> (Red Hat <span class="number">4.4</span>.<span class="number">7</span>-<span class="number">16</span>) (GCC)</span><br><span class="line">COMPILER_PATH=/usr/libexec/gcc/x86_64-redhat-linux/<span class="number">4.4</span>.<span class="number">7</span>/:/usr/libexec/gcc/x86_64-redhat-linux/<span class="number">4.4</span>.<span class="number">7</span>/:/usr/libexec/gcc/x86_64-redhat-linux/:/usr/lib/gcc/x86_64-redhat-linux/<span class="number">4.4</span>.<span class="number">7</span>/:/usr/lib/gcc/x86_64-redhat-linux/:/usr/libexec/gcc/x86_64-redhat-linux/<span class="number">4.4</span>.<span class="number">7</span>/:/usr/libexec/gcc/x86_64-redhat-linux/:/usr/lib/gcc/x86_64-redhat-linux/<span class="number">4.4</span>.<span class="number">7</span>/:/usr/lib/gcc/x86_64-redhat-linux/</span><br><span class="line">LIBRARY_PATH=/usr/lib/gcc/x86_64-redhat-linux/<span class="number">4.4</span>.<span class="number">7</span>/:/usr/lib/gcc/x86_64-redhat-linux/<span class="number">4.4</span>.<span class="number">7</span>/:/usr/lib/gcc/x86_64-redhat-linux/<span class="number">4.4</span>.<span class="number">7</span>/../../../../lib64/:/lib/../lib64/:/usr/lib/../lib64/:/usr/lib/gcc/x86_64-redhat-linux/<span class="number">4.4</span>.<span class="number">7</span>/../../../:/lib/:/usr/lib/</span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">'-v'</span> <span class="string">'-mtune=generic'</span></span><br><span class="line"> /usr/libexec/gcc/x86_64-redhat-linux/<span class="number">4.4</span>.<span class="number">7</span>/collect2 --eh-frame-hdr --build-id -m elf_x86_64 --hash-style=gnu -dynamic-linker /lib64/ld-linux-x86-<span class="number">64</span>.so.<span class="number">2</span> /usr/lib/gcc/x86_64-redhat-linux/<span class="number">4.4</span>.<span class="number">7</span>/../../../../lib64/crt1.o /usr/lib/gcc/x86_64-redhat-linux/<span class="number">4.4</span>.<span class="number">7</span>/../../../../lib64/crti.o /usr/lib/gcc/x86_64-redhat-linux/<span class="number">4.4</span>.<span class="number">7</span>/crtbegin.o -L/usr/lib/gcc/x86_64-redhat-linux/<span class="number">4.4</span>.<span class="number">7</span> -L/usr/lib/gcc/x86_64-redhat-linux/<span class="number">4.4</span>.<span class="number">7</span> -L/usr/lib/gcc/x86_64-redhat-linux/<span class="number">4.4</span>.<span class="number">7</span>/../../../../lib64 -L/lib/../lib64 -L/usr/lib/../lib64 -L/usr/lib/gcc/x86_64-redhat-linux/<span class="number">4.4</span>.<span class="number">7</span>/../../.. -lpython2.<span class="number">7</span> -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-redhat-linux/<span class="number">4.4</span>.<span class="number">7</span>/crtend.o /usr/lib/gcc/x86_64-redhat-linux/<span class="number">4.4</span>.<span class="number">7</span>/../../../../lib64/crtn.o</span><br><span class="line">/usr/bin/ld: cannot find -lpython2.<span class="number">7</span></span><br><span class="line">collect2: ld returned <span class="number">1</span> <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure></p>
<p>可以看到**/usr/local/python27/lib**并不在上面的路径, google一下找到了这个答案<a href="http://stackoverflow.com/questions/8400272/usr-bin-ld-cannot-find-lpython2-7" target="_blank" rel="external">http://stackoverflow.com/questions/8400272/usr-bin-ld-cannot-find-lpython2-7</a>, 然后</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@micaopan-dev lib]<span class="comment"># locate libpython2.7.a</span></span><br><span class="line">/usr/<span class="built_in">local</span>/python27/lib/python2.<span class="number">7</span>/config/libpython2.<span class="number">7</span>.a</span><br><span class="line">/usr/<span class="built_in">local</span>/src/Python-<span class="number">2.7</span>.<span class="number">8</span>/libpython2.<span class="number">7</span>.a</span><br><span class="line">[root@micaopan-dev lib]<span class="comment"># ln -s /usr/local/python27/lib/python2.7/config/libpython2.7.a /usr/lib</span></span><br><span class="line">[root@micaopan-dev lib]<span class="comment"># gcc -lpython2.7 --verbose</span></span><br><span class="line">...</span><br><span class="line">(.text+<span class="number">0</span>x20): undefined reference to <span class="string">'main'</span></span><br><span class="line">collect2: ld returned <span class="number">1</span> <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure></p>
<p>这个gcc找到了动态链接库, 报错根据<a href="http://stackoverflow.com/questions/15905119/c-linking-error-undefined-reference-to-main" target="_blank" rel="external">http://stackoverflow.com/questions/15905119/c-linking-error-undefined-reference-to-main</a>应该并没有什么大碍</p>
<p>然后执行<code>pip install cffi</code>成功.</p>
<p>PS: 参考</p>
<ol>
<li><a href="http://navyaijm.blog.51cto.com/4647068/809424" target="_blank" rel="external">/usr/bin/ld: cannot find -l* 错误的解决方法……</a></li>
<li><a href="http://eminzhang.blog.51cto.com/5292425/1285705" target="_blank" rel="external">关于usr/bin/ld: cannot find -lxxx问题总结</a></li>
<li><a href="http://stackoverflow.com/questions/8400272/usr-bin-ld-cannot-find-lpython2-7" target="_blank" rel="external">/usr/bin/ld: cannot find -lpython2.7</a></li>
<li><a href="http://stackoverflow.com/questions/15905119/c-linking-error-undefined-reference-to-main" target="_blank" rel="external">C Linking Error: undefined reference to 'main'</a></li>
</ol>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Python/issue-when-install-python-cffi.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Ubuntu添加可信任根证书]]></title>
      <link>http://yaxin-cn.github.io/Linux/add-root-certificate-in-ubuntu.html</link>
      <guid>http://yaxin-cn.github.io/Linux/add-root-certificate-in-ubuntu.html</guid>
      <pubDate>Thu, 21 May 2015 03:58:45 GMT</pubDate>
      <description>
      <![CDATA[<h2>添加</h2>
<p>Ubuntu下添加根证书非常简单, 只要将证书(扩展名为crt)复制到**/usr/local/share/ca-certificates**文件夹然后运行<code>update-ca-certificates</code>即可</p>
<p><f]]>
      </description>
      <content:encoded><![CDATA[<h2>添加</h2>
<p>Ubuntu下添加根证书非常简单, 只要将证书(扩展名为crt)复制到**/usr/local/share/ca-certificates**文件夹然后运行<code>update-ca-certificates</code>即可</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@ubox ~]<span class="variable">$sudo</span> cp xinmu.crt /usr/<span class="built_in">local</span>/share/ca-certificates</span><br><span class="line">[yaxin@ubox ~]<span class="variable">$sudo</span> update-ca-certificates</span><br><span class="line">Updating certificates <span class="keyword">in</span> /etc/ssl/certs... <span class="number">1</span> added, <span class="number">0</span> removed; done.</span><br><span class="line">Running hooks <span class="keyword">in</span> /etc/ca-certificates/update.d....done.</span><br></pre></td></tr></table></figure></p>
<h2>删除</h2>
<p>直接将**/usr/local/share/ca-certificates**对应的证书删除，然后执行<code>update-ca-certificates</code></p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@ubox ~]<span class="variable">$sudo</span> rm <span class="operator">-f</span> /usr/<span class="built_in">local</span>/share/ca-certificates/xinmu.crt</span><br><span class="line">[yaxin@ubox ~]<span class="variable">$sudo</span> update-ca-certificates</span><br><span class="line">Updating certificates <span class="keyword">in</span> /etc/ssl/certs... <span class="number">0</span> added, <span class="number">0</span> removed; done.</span><br><span class="line">Running hooks <span class="keyword">in</span> /etc/ca-certificates/update.d....done.</span><br></pre></td></tr></table></figure></p>
<p><strong>注意: 这时候并不会提示1 removed, 但证书是已经被删除了的</strong></p>
<h2>原理</h2>
<p>其实<code>update-ca-certificates</code>是一个shell脚本, 使用<code>which</code>找出<code>update-ca-certificates</code>的绝对路径，然后打开就可以查看其源码</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@ubox ~]<span class="variable">$which</span> update-ca-certificates</span><br><span class="line">/usr/sbin/update-ca-certificates</span><br><span class="line">[yaxin@ubox ~]<span class="variable">$file</span> /usr/sbin/update-ca-certificates</span><br><span class="line">/usr/sbin/update-ca-certificates: POSIX shell script, ASCII text executable</span><br></pre></td></tr></table></figure></p>
<p>通过阅读源码可以看出, <code>update-ca-certificates</code>命令的本质其实是将PEM格式的根证书内容附加到*/etc/ssl/certs/ca-certificates.crt*, 而*/etc/ssl/certs/ca-certificates.crt*中本身就包含了系统自带的各种可信根证书.</p>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Linux/add-root-certificate-in-ubuntu.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[管理ubuntu server自启程序]]></title>
      <link>http://yaxin-cn.github.io/Linux/manage-startup-program-on-ubuntu-server.html</link>
      <guid>http://yaxin-cn.github.io/Linux/manage-startup-program-on-ubuntu-server.html</guid>
      <pubDate>Wed, 13 May 2015 12:28:30 GMT</pubDate>
      <description>
      <![CDATA[<p>本文所使用的环境为ubuntu14.04，ubuntu15.04使用systemd，可能会有很大的不同</p>
<h2>方法一</h2>
<p>使用类图形的<code>sysv-rc-conf</code>命令，你需要首先安装<code>sysv-rc-conf</code]]>
      </description>
      <content:encoded><![CDATA[<p>本文所使用的环境为ubuntu14.04，ubuntu15.04使用systemd，可能会有很大的不同</p>
<h2>方法一</h2>
<p>使用类图形的<code>sysv-rc-conf</code>命令，你需要首先安装<code>sysv-rc-conf</code></p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@~]<span class="variable">$sudo</span> apt-get install sysv-rc-conf</span><br><span class="line">[yaxin@~]<span class="variable">$sudo</span> sysv-rc-conf</span><br></pre></td></tr></table></figure></p>
<p>运行之后会有一个类图形的界面, 这个操作起来相当简单, 也容易懂，这里就不多介绍</p>
<h2>方法二</h2>
<p>首先使用<code>runlevel</code>命令获取系统运行在哪个<strong>level</strong>下（ubuntu server一般是2），如下：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@~]<span class="variable">$runlevel</span></span><br><span class="line">N <span class="number">2</span></span><br><span class="line">[yaxin@~]$</span><br></pre></td></tr></table></figure></p>
<p>然后将启动脚本放到<code>/etc/rcX.d</code> 其中X为运行级别，如<code>/etc/rc2.d</code>, 注意脚本要以大写<strong>S</strong>开头, 后面接一个两位数的数字，表示启动顺序，数字越小表示越先启动</p>
<p>一般<code>/etc/rc2.d</code>中会有很多软链接到<code>/etc/init.d</code>下的启动脚本, 这样的好处是集中管理，很方便, 并且可以使用<code>service</code>这个程序对进程进行重启等操作.</p>
<p>如，编译安装完php后，将<code>sapi/fpm</code>文件夹下的<code>init.d.php-fpm</code>文件复制到<code>/etc/init.d</code>文件夹下，然后在<code>/etc/rc2.d</code>下创建一个软链接</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@php-<span class="number">5.6</span>.<span class="number">8</span>]<span class="variable">$sudo</span> cp sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm</span><br><span class="line">[yaxin@php-<span class="number">5.6</span>.<span class="number">8</span>]<span class="variable">$sudo</span> chmod +x /etc/init.d/php-fpm</span><br><span class="line">[yaxin@php-<span class="number">5.6</span>.<span class="number">8</span>]<span class="variable">$sudo</span> ln <span class="operator">-s</span> /etc/init.d/php-fpm /etc/rc2.d/S20php-fpm</span><br><span class="line">[yaxin@php-<span class="number">5.6</span>.<span class="number">8</span>]<span class="variable">$service</span> php-fpm start</span><br></pre></td></tr></table></figure></p>
<p>当然，如果你想关闭一个自启的程序，直接将对应的<code>/etc/rcX.d</code>下的启动脚本删除即可</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@~]<span class="variable">$sudo</span> rm /etc/rc2.d/S20php-fpm</span><br></pre></td></tr></table></figure></p>
<p>或则</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@~]<span class="variable">$sudo</span> unlink /etc/rc2.d/S20php-fpm</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>: <code>sysv-rc-conf</code>命令就是使用这个方法来实现程序自启和禁止自启的.</p>
<h2>方法三</h2>
<p>直接将需要启动的程序添加到<code>/etc/rc.local</code>文件中</p>
<p>如你需要开机启动nginx，那么可以这样</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@~]<span class="variable">$echo</span> <span class="string">"/etc/nginx/sbin/nginx"</span> &gt;&gt; /etc/rc.local</span><br></pre></td></tr></table></figure></p>
<p>其实这个就是方法二的快捷操作，如果你查看<code>/etc/rc2.d</code>文件夹下面的文件会发现有一个<code>S99rc.local</code>的软链接，它链接到<code>/etc/init.d/rc.local</code>, 而<code>/etc/init.d/rc.local</code>这个脚本中又会执行<code>/etc/rc.local</code>这个脚本</p>
<h3>方法四</h3>
<p>其实前几种方式并不是正统的自启管理方式, 使用<code>rcX.d</code>是<strong>传统init</strong>的方式, 而ubuntu14.04是使用<strong>Upstart</strong>来初始化守护进程, 但为了照顾使用从<strong>init</strong>过来(如centos6等)的人才创建的. 而真正的启动脚本(应该说配置)是放在<code>/etc/init</code>这个文件夹下的</p>
<p><code>/etc/init</code>文件夹下有很多的以**.conf**结尾的文件，这些就是正统的管理自启程序的配置文件.</p>
<p>随便打开一个文件, 有一行<strong>start on runlevel [234]</strong>, 这就说明在runlevel为234的情况下启动</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@/etc/init]<span class="variable">$head</span> ssh.conf</span><br><span class="line"><span class="comment"># ssh - OpenBSD Secure Shell server</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The OpenSSH server provides secure shell access to the system.</span></span><br><span class="line"></span><br><span class="line">description <span class="string">"OpenSSH server"</span></span><br><span class="line"></span><br><span class="line">start on runlevel [<span class="number">2345</span>]</span><br><span class="line">stop on runlevel [!<span class="number">2345</span>]</span><br></pre></td></tr></table></figure></p>
<p>如上，ssh将在runlevel为2 3 4 5的时候开机启动, 而启动的具体命令在配置文件后面.</p>
<p>当然，如果你想关闭自启，那么删除但钱runlevel即可，或则直接删除该配置文件.</p>
<p>所以，如果你有一个开机自启的程序，当你使用前面的方法删除以后，程序还是自启，那么问题肯定出在这一步.</p>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Linux/manage-startup-program-on-ubuntu-server.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Python中的类方法和静态方法]]></title>
      <link>http://yaxin-cn.github.io/Python/classmethod-and-staticmethod-in-python.html</link>
      <guid>http://yaxin-cn.github.io/Python/classmethod-and-staticmethod-in-python.html</guid>
      <pubDate>Mon, 22 Dec 2014 03:41:56 GMT</pubDate>
      <description>
      <![CDATA[<p>Python类中有两个特殊的修饰符@classmethod和@staticmethod(即类方法和静态方法), 想要理解需要先理解类属性和实例属性的感念</p>
<h2>类属性和实例属性</h2>
<p>看下面的代码</p>
<p><figure class="highli]]>
      </description>
      <content:encoded><![CDATA[<p>Python类中有两个特殊的修饰符@classmethod和@staticmethod(即类方法和静态方法), 想要理解需要先理解类属性和实例属性的感念</p>
<h2>类属性和实例属性</h2>
<p>看下面的代码</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class TestProperty(object):</span><br><span class="line">...     class_property = "class property"</span><br><span class="line">...     </span><br><span class="line">...     def __init__(self):</span><br><span class="line">...         self.instance_property = "instance property"</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; test_property = TestProperty()</span><br><span class="line">&gt;&gt;&gt; # 实例可以访问实例属性和类属性</span><br><span class="line">&gt;&gt;&gt; print test_property.class_property</span><br><span class="line">class property</span><br><span class="line">&gt;&gt;&gt; print test_property.instance_property</span><br><span class="line">instance property</span><br><span class="line">&gt;&gt;&gt; # 类可以访问类属性</span><br><span class="line">&gt;&gt;&gt; print TestProperty.class_property</span><br><span class="line">class property</span><br><span class="line">&gt;&gt;&gt; # 但不可以访问实例属性</span><br><span class="line">&gt;&gt;&gt; print TestProperty.instance_property</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: type object 'TestProperty' has no attribute 'instance_property'</span><br><span class="line">&gt;&gt;&gt; # 注意下面的报错</span><br><span class="line">&gt;&gt;&gt; del test_property.class_property</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: class_property</span><br></pre></td></tr></table></figure></p>
<p>总结起来就是:</p>
<ol>
<li><strong>实例属性</strong>的初始化在<code>__init__</code>构造器方法中进行(当然也可以通过其它方法赋值)</li>
<li><strong>类实例</strong>可以访问实例属性和类属性</li>
<li>通过类本身则能访问类属性,无法访问实例属性</li>
<li>类属性与类实例没有任何关系</li>
<li>类属性其实就是其它语言中的静态变量(变量前加static)</li>
<li>为什么要有类属性, 一句话<strong>命名空间</strong></li>
</ol>
<h2>类方法和静态方法</h2>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class TestMethod(object):</span><br><span class="line">...     class_property = "class property"</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...         self.instance_property = "instance property"</span><br><span class="line">...     def instance_method(self, arvg):</span><br><span class="line">...         print "instance_method(%s, %s)" % (self, arvg)</span><br><span class="line">...         print "instance property: ", self.instance_property</span><br><span class="line">...     @classmethod</span><br><span class="line">...     def class_method(cls, arvg):</span><br><span class="line">...         print "class_method(%s, %s)" % (cls, arvg)</span><br><span class="line">...         print "class property: ", cls.class_property</span><br><span class="line">...     @staticmethod</span><br><span class="line">...     def static_method(arvg):</span><br><span class="line">...         print "static_method(%s)" % arvg</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; test_method = TestMethod()</span><br><span class="line">&gt;&gt;&gt; # 执行普通方法, 打印出实例的内存地址和实例属性</span><br><span class="line">&gt;&gt;&gt; test_method.instance_method("Hello")</span><br><span class="line">instance_method(&lt;__main__.TestMethod object at 0x7fd8fc56eb90&gt;, Hello)</span><br><span class="line">instance property:  instance property</span><br><span class="line">&gt;&gt;&gt; # 执行类方法</span><br><span class="line">&gt;&gt;&gt; # 通过实例访问, 打印出类本身和类属性</span><br><span class="line">&gt;&gt;&gt; test_method.class_method("Hello")</span><br><span class="line">class_method(&lt;class '__main__.TestMethod'&gt;, Hello)</span><br><span class="line">class property:  class property</span><br><span class="line">&gt;&gt;&gt; # 通过类直接访问, 同上</span><br><span class="line">&gt;&gt;&gt; TestMethod.class_method("Hello")</span><br><span class="line">class_method(&lt;class '__main__.TestMethod'&gt;, Hello)</span><br><span class="line">class property:  class property</span><br><span class="line">&gt;&gt;&gt; # 执行静态方法</span><br><span class="line">&gt;&gt;&gt; # 通过实例访问, 打印出静态方法本身</span><br><span class="line">&gt;&gt;&gt; test_method.static_method("Hello")</span><br><span class="line">static_method(Hello)</span><br><span class="line">&gt;&gt;&gt; # 通过类直接访问, 同上</span><br><span class="line">&gt;&gt;&gt; TestMethod.static_method("Hello")</span><br><span class="line">static_method(Hello)</span><br></pre></td></tr></table></figure></p>
<p>可以看出类方法中<code>cls</code>代表的是类本身, 如果将类方法中的访问类属性的cls去掉, 则会报出<em>NameError</em>的错误</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">TestMethod</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="prompt">... </span>    class_property = <span class="string">"class property"</span></span><br><span class="line"><span class="prompt">... </span>    <span class="decorator">@classmethod</span></span><br><span class="line"><span class="prompt">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">class_method</span><span class="params">(cls, arvg)</span>:</span></span><br><span class="line"><span class="prompt">... </span>        <span class="keyword">print</span> <span class="string">"class property: "</span>, cls.class_property</span><br><span class="line"><span class="prompt">... </span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>TestMethod.class_method(<span class="string">"Hello"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">property</span>:</span> </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">5</span>, <span class="keyword">in</span> class_method</span><br><span class="line">NameError: <span class="keyword">global</span> name <span class="string">'class_property'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure></p>
<ol>
<li><strong>类方法是为了访问类属性更加方便</strong></li>
<li>类方法和静态方法可以通过类和实例来访问,效果是相同的</li>
<li>静态方法跟普通函数没有什么区别</li>
</ol>
<p>可以通过在实例方法中直接通过<code>TestMethod.class_property</code>来访问, 但是这样不方便也不好维护(如果类名称改了,就会出错), 也可以使用<code>self.class_property</code>来访问, 但注意, 实例本身获取的并不应该是类属性即<code>TestMethod.class_property</code>, 只是因为实例中并没有<code>class_property</code>这个变量, 而是通过查找类属性,发现有同名变量,然后打印出来,通过上面无法实例无法删除类属性是可以看出来的. 当然,如果不信,可以看下面的例子</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class TestMethod(object):</span><br><span class="line">...     class_property = "class property"</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...         pass</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; test_method = TestMethod()</span><br><span class="line">&gt;&gt;&gt; id(test_method.class_property)</span><br><span class="line">140488040794968</span><br><span class="line">&gt;&gt;&gt; id(TestMethod.class_property)</span><br><span class="line">140488040794968</span><br><span class="line">&gt;&gt;&gt; print test_method.class_property</span><br><span class="line">class property</span><br><span class="line">&gt;&gt;&gt; test_method.class_property = test_method.class_property + "!!!"</span><br><span class="line">&gt;&gt;&gt; print test_method.class_property</span><br><span class="line">class property!!!</span><br><span class="line">&gt;&gt;&gt; print TestMethod.class_property</span><br><span class="line">class property</span><br><span class="line">&gt;&gt;&gt; id(test_method.class_property)</span><br><span class="line">140488040795080</span><br><span class="line">&gt;&gt;&gt; id(TestMethod.class_property)</span><br><span class="line">140488040794968</span><br></pre></td></tr></table></figure></p>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Python/classmethod-and-staticmethod-in-python.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Docker中使用固定IP]]></title>
      <link>http://yaxin-cn.github.io/Docker/docker-container-use-static-IP.html</link>
      <guid>http://yaxin-cn.github.io/Docker/docker-container-use-static-IP.html</guid>
      <pubDate>Thu, 11 Dec 2014 06:14:08 GMT</pubDate>
      <description>
      <![CDATA[<p>默认情况下启动一个container，其会自动获取一个跟<code>docker0</code>同网段的IP，而且重启container其IP一般会发生变化，但有时候我们会需要固定的IP。要实现这个并不困难。</p>
<p><a href="https://docs.doc]]>
      </description>
      <content:encoded><![CDATA[<p>默认情况下启动一个container，其会自动获取一个跟<code>docker0</code>同网段的IP，而且重启container其IP一般会发生变化，但有时候我们会需要固定的IP。要实现这个并不困难。</p>
<p><a href="https://docs.docker.com/reference/commandline/cli/#run" target="_blank" rel="external"><code>docker run</code></a>启动一个container的命令有一个<code>--net</code>的参数用于指定container的网络类型</p>
<blockquote>
<p>--net=&quot;bridge&quot;  Set the Network mode for the container
     'bridge': creates a new network stack for the container on the docker bridge
     'none': no networking for this container
     'container:&lt;name|id&gt;': reuses another container network stack
     'host': use the host network stack inside the container.  Note: the host mode gives the container full access to local system services such as D-bus and is therefore considered insecure.</p>
</blockquote>
<p>docker默认使用'bridge'来设置container的网络模式（即从与docker0同网段的未使用的IP中取一个作为container的IP），我们这里使用'<strong>none</strong>'来实现自己手动配置container的网络。</p>
<p>首先我们以**<code>--net='none'</code>**的方式启动一个container</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[yaxin@cube2x ~]$docker run -i -t --rm --net=&#39;none&#39; ubuntu /bin/bash&#10;root@db84e747c362:/# ifconfig -a&#10;lo        Link encap:Local Loopback&#10;          inet addr:127.0.0.1  Mask:255.0.0.0&#10;          inet6 addr: ::1/128 Scope:Host&#10;          UP LOOPBACK RUNNING  MTU:65536  Metric:1&#10;          RX packets:0 errors:0 dropped:0 overruns:0 frame:0&#10;          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0&#10;          collisions:0 txqueuelen:0&#10;          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)&#10;&#10;root@db84e747c362:/#</span><br></pre></td></tr></table></figure></p>
<p>可以看到，由于我们使用'none'模式，container中没有获取到IP，甚至连网卡都没有，下面我们开始给container配置IP</p>
<p>首先获取container的pid（我们需要通过pid获取file descriptor）</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@cube2x ~]<span class="variable">$docker</span> ps</span><br><span class="line">CONTAINER ID        IMAGE                            COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">db84e747c362        docker.cn/docker/ubuntu:latest   <span class="string">"/bin/bash"</span>         <span class="number">4</span> minutes ago       Up <span class="number">4</span> minutes                            sharp_kirch</span><br><span class="line">[yaxin@cube2x ~]<span class="variable">$docker</span> inspect <span class="operator">-f</span> &#123;% raw %&#125;<span class="string">"&#123;&#123;.State.Pid&#125;&#125;"</span>&#123;% endraw %&#125; sharp_kirch</span><br><span class="line"><span class="number">23090</span></span><br></pre></td></tr></table></figure></p>
<p>ip-netns的man page中有这样一句</p>
<blockquote>
<p>By convention a named network namespace is an object at /var/run/netns/NAME that can be opened.  The file descriptor resulting from opening/var/run/netns/NAME refers to the specified network namespace</p>
</blockquote>
<p>因而我们需要创建一个链接</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[yaxin@cube2x ~]$sudo ln -s /proc/23090/ns/net /var/run/netns/23090</span><br></pre></td></tr></table></figure></p>
<p>然后创建一对端到端的网卡，将<code>veth_db84e747c3</code>绑定到docker0网桥，并启动。将另一块网卡<code>X</code>放到container内部</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[yaxin@cube2x ~]$sudo ip link add veth_db84e747c3 type veth peer name X&#10;[yaxin@cube2x ~]$sudo brctl addif docker0 veth_db84e747c3&#10;[yaxin@cube2x ~]$sudo ip link set veth_db84e747c3 up&#10;[yaxin@cube2x ~]$sudo ip link set X netns 23090</span><br></pre></td></tr></table></figure></p>
<p>这时查看container的IP，会发现多了一个名为<code>X</code>的网卡</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">root@db84e747c362:/# ifconfig  -a&#10;X         Link encap:Ethernet  HWaddr 5a:7e:4d:ba:63:1c  &#10;          BROADCAST MULTICAST  MTU:1500  Metric:1&#10;          RX packets:0 errors:0 dropped:0 overruns:0 frame:0&#10;          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0&#10;          collisions:0 txqueuelen:1000 &#10;          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)&#10;&#10;lo        Link encap:Local Loopback  &#10;          inet addr:127.0.0.1  Mask:255.0.0.0&#10;          inet6 addr: ::1/128 Scope:Host&#10;          UP LOOPBACK RUNNING  MTU:65536  Metric:1&#10;          RX packets:0 errors:0 dropped:0 overruns:0 frame:0&#10;          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0&#10;          collisions:0 txqueuelen:0 &#10;          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)&#10;&#10;root@db84e747c362:/#</span><br></pre></td></tr></table></figure></p>
<p>然后对container内部新添加的网卡进行配置（可以通过<code>man ip-netns</code>更详细查看）</p>
<p><figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line">[yaxin@cube2x ~]$sudo <span class="literal">ip</span> netns <span class="keyword">exec</span> <span class="number">23090</span> <span class="literal">ip</span> <span class="literal">link</span> set dev <span class="constant">X</span> <span class="literal">name</span> eth<span class="number">0</span></span><br><span class="line">[yaxin@cube2x ~]$sudo <span class="literal">ip</span> netns <span class="keyword">exec</span> <span class="number">23090</span> <span class="literal">ip</span> <span class="literal">link</span> set eth<span class="number">0</span> up</span><br><span class="line">[yaxin@cube2x ~]$sudo <span class="literal">ip</span> netns <span class="keyword">exec</span> <span class="number">23090</span> <span class="literal">ip</span> addr add <span class="number">172.17</span>.<span class="number">111.10</span>/<span class="number">16</span> dev eth<span class="number">0</span></span><br><span class="line">[yaxin@cube2x ~]$sudo <span class="literal">ip</span> netns <span class="keyword">exec</span> <span class="number">23090</span> <span class="literal">ip</span> route add <span class="keyword">default</span> via <span class="number">172.17</span>.<span class="number">42.1</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注意: 指定给container的IP必须跟docker0在同一网段,且给container的网关应该为docker0的IP</strong></p>
<p>最后，写成shell脚本如下:</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env bash&#10;# filename: bind_addr.sh&#10;&#10;if [ `id -u` -ne 0 ];then&#10;    echo &#39;&#24517;&#39035;&#20351;&#29992;root&#26435;&#38480;&#39;&#10;    exit&#10;fi&#10;&#10;if [ $# != 2 ]; then&#10;    echo &#34;&#20351;&#29992;&#26041;&#27861;: $0 &#23481;&#22120;&#21517;&#23383; IP&#34;&#10;    exit 1&#10;fi&#10;&#10;container_name=$1&#10;bind_ip=$2&#10;&#10;container_id=`docker inspect -f &#123;% raw %&#125;&#39;&#123;&#123;.Id&#125;&#125;&#39;&#123;% endraw %&#125; $container_name 2&#62; /dev/null`&#10;if [ ! $container_id ];then&#10;    echo &#34;&#23481;&#22120;&#19981;&#23384;&#22312;&#34;&#10;    exit 2&#10;fi&#10;bind_ip=`echo $bind_ip | egrep &#39;^(([0-9]|[1-9][0-9]|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5])\.)&#123;3&#125;([0-9]|[1-9][0-9]|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5])$&#39;`&#10;if [ ! $bind_ip ];then&#10;    echo &#34;IP&#22320;&#22336;&#26684;&#24335;&#19981;&#27491;&#30830;&#34;&#10;    exit 3&#10;fi&#10;&#10;container_minid=`echo $container_id | cut -c 1-10`&#10;container_netmask=`ip addr show docker0 | grep &#34;inet\b&#34; | awk &#39;&#123;print $2&#125;&#39; | cut -d / -f2`&#10;container_gw=`ip addr show docker0 | grep &#34;inet\b&#34; | awk &#39;&#123;print $2&#125;&#39; | cut -d / -f1`&#10;&#10;bridge_name=&#34;veth_$container_minid&#34;&#10;container_ip=$bind_ip/$container_netmask&#10;pid=`docker inspect -f &#123;% raw %&#125;&#39;&#123;&#123;.State.Pid&#125;&#125;&#39;&#123;% endraw %&#125; $container_name 2&#62; /dev/null`&#10;if [ ! $pid ];then&#10;    echo &#34;&#33719;&#21462;&#23481;&#22120;$container_name&#30340;id&#22833;&#36133;&#34;&#10;    exit 4&#10;fi&#10;&#10;if [ ! -d /var/run/netns ];then&#10;    mkdir -p /var/run/netns&#10;fi&#10;&#10;ln -sf /proc/$pid/ns/net /var/run/netns/$pid&#10;&#10;ip link add $bridge_name type veth peer name X&#10;brctl addif docker0 $bridge_name&#10;ip link set $bridge_name up&#10;ip link set X netns $pid&#10;ip netns exec $pid ip link set dev X name eth0&#10;ip netns exec $pid ip link set eth0 up&#10;ip netns exec $pid ip addr add $container_ip dev eth0&#10;ip netns exec $pid ip route add default via $container_gw</span><br></pre></td></tr></table></figure></p>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Docker/docker-container-use-static-IP.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Python实现矩阵加法运算]]></title>
      <link>http://yaxin-cn.github.io/Python/matrix-addition-in-python.html</link>
      <guid>http://yaxin-cn.github.io/Python/matrix-addition-in-python.html</guid>
      <pubDate>Fri, 07 Nov 2014 10:04:06 GMT</pubDate>
      <description>
      <![CDATA[<p>写一个数据分析的程序，中间要处理一个2x3矩阵的相加，遂写出了下面的代码</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span cl]]>
      </description>
      <content:encoded><![CDATA[<p>写一个数据分析的程序，中间要处理一个2x3矩阵的相加，遂写出了下面的代码</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_matrix_add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(x)):</span><br><span class="line">        result.append(tuple(map(<span class="keyword">lambda</span> t: reduce(add, t), zip(x[i], y[i]))))</span><br><span class="line">    <span class="keyword">return</span> tuple(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matrix_add</span><span class="params">(matrix_list)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(two_matrix_add, matrix_list)</span><br></pre></td></tr></table></figure></p>
<p>下面测试一下：</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>matrix_1 = [</span><br><span class="line"><span class="prompt">... </span>    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line"><span class="prompt">... </span>    [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line"><span class="prompt">... </span>    [<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line"><span class="prompt">... </span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>matrix_2 = [</span><br><span class="line"><span class="prompt">... </span>    [<span class="number">128</span>, <span class="number">204</span>, <span class="number">125</span>, <span class="number">66</span>],</span><br><span class="line"><span class="prompt">... </span>    [<span class="number">230</span>, <span class="number">222</span>, <span class="number">186</span>, <span class="number">220</span>],</span><br><span class="line"><span class="prompt">... </span>    [<span class="number">110</span>, <span class="number">86</span>, <span class="number">176</span>, <span class="number">249</span>]</span><br><span class="line"><span class="prompt">... </span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>matrix_3 = [</span><br><span class="line"><span class="prompt">... </span>    [<span class="number">189</span>, <span class="number">138</span>, <span class="number">188</span>, <span class="number">113</span>],</span><br><span class="line"><span class="prompt">... </span>    [<span class="number">214</span>, <span class="number">85</span>, <span class="number">180</span>, <span class="number">217</span>],</span><br><span class="line"><span class="prompt">... </span>    [<span class="number">126</span>, <span class="number">195</span>, <span class="number">203</span>, <span class="number">207</span>]</span><br><span class="line"><span class="prompt">... </span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>matrix_add([matrix_1, matrix_2])</span><br><span class="line">((<span class="number">128</span>, <span class="number">205</span>, <span class="number">127</span>, <span class="number">69</span>), (<span class="number">234</span>, <span class="number">227</span>, <span class="number">192</span>, <span class="number">227</span>), (<span class="number">118</span>, <span class="number">95</span>, <span class="number">186</span>, <span class="number">260</span>))</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>matrix_add([matrix_1, matrix_2, matrix_3])</span><br><span class="line">((<span class="number">317</span>, <span class="number">343</span>, <span class="number">315</span>, <span class="number">182</span>), (<span class="number">448</span>, <span class="number">312</span>, <span class="number">372</span>, <span class="number">444</span>), (<span class="number">244</span>, <span class="number">290</span>, <span class="number">389</span>, <span class="number">467</span>))</span><br></pre></td></tr></table></figure></p>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Python/matrix-addition-in-python.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[更改ubuntu语系和时区]]></title>
      <link>http://yaxin-cn.github.io/Linux/change-locale-and-timezone-of-ubuntu.html</link>
      <guid>http://yaxin-cn.github.io/Linux/change-locale-and-timezone-of-ubuntu.html</guid>
      <pubDate>Tue, 04 Nov 2014 07:59:29 GMT</pubDate>
      <description>
      <![CDATA[<h2>一、修改时区</h2>
<h3>1. 交互式修改</h3>
<p>ubuntu提供了一个交互式的选择时区的命令<code>dpkg-reconfigure tzdata</code>，直接在命令行中输入此命令，然后选择自己的时区即可</p>
<h3>2. 直接修改</h3]]>
      </description>
      <content:encoded><![CDATA[<h2>一、修改时区</h2>
<h3>1. 交互式修改</h3>
<p>ubuntu提供了一个交互式的选择时区的命令<code>dpkg-reconfigure tzdata</code>，直接在命令行中输入此命令，然后选择自己的时区即可</p>
<h3>2. 直接修改</h3>
<p>另外一种方法相对简单，即直接复制相应的时区文件覆盖当前系统的时区文件</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@ubox:~]$ cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">[yaxin@ubox:~]$ date</span><br><span class="line">Tue Nov  <span class="number">4</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">55</span> CST <span class="number">2014</span></span><br></pre></td></tr></table></figure></p>
<p>修改是立即生效的。</p>
<h2>二、修改语系</h2>
<p>首先你需要使用<code>locale-gen</code>编译locale定义文件，直接在命令后面指定要编译的locale（可以查看/usr/share/i18n/SUPPORTED来获取locale的格式）</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@ubox:~]$ sudo locale-gen zh_CN.UTF-<span class="number">8</span> en_US.UTF-<span class="number">8</span></span><br><span class="line">Generating locales...</span><br><span class="line">  en_US.UTF-<span class="number">8</span>... up-to-date</span><br><span class="line">  zh_CN.UTF-<span class="number">8</span>... up-to-date</span><br><span class="line">Generation complete.</span><br><span class="line">[yaxin@ubox:~]$ <span class="built_in">echo</span> <span class="string">'LANG="en_US.UTF-8"'</span> &gt; /etc/default/locale</span><br></pre></td></tr></table></figure></p>
<p>语系的修改并不是立即生效的，你需要重启机器才能生效。</p>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Linux/change-locale-and-timezone-of-ubuntu.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[PHP中的DateTime类]]></title>
      <link>http://yaxin-cn.github.io/PHP/class-datetime-in-php.html</link>
      <guid>http://yaxin-cn.github.io/PHP/class-datetime-in-php.html</guid>
      <pubDate>Fri, 22 Aug 2014 04:13:30 GMT</pubDate>
      <description>
      <![CDATA[<p><a href="http://php.net/manual/zh/class.datetime.php" target="_blank" rel="external"><code>DataTime</code></a>类跟<code>date()</code>,<code]]>
      </description>
      <content:encoded><![CDATA[<p><a href="http://php.net/manual/zh/class.datetime.php" target="_blank" rel="external"><code>DataTime</code></a>类跟<code>date()</code>,<code>strtotime()</code>,<code>gmdate()</code>等函数有相同的作用，都是用来处理日期和时间的，但<code>DateTime</code>类更加直观、方便, 所以在PHP5.2.0以后推荐使用<code>DateTime</code>类而不是相应的函数。</p>
<p>下面来看一下<code>DateTime</code>类的用法。</p>
<h2>1. 获取当前系统时间并打印</h2>
<p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="variable">$date</span> = <span class="keyword">new</span> DateTime();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$date</span>-&gt;format(<span class="string">'Y-m-d H:i:s'</span>);</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>执行结果为：2014-08-25 12:58:29</p>
</blockquote>
<h2>2. 获取特定时间并打印</h2>
<p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="variable">$date</span> = <span class="keyword">new</span> DateTime(<span class="string">'2014-05-04'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$date</span>-&gt;format(<span class="string">'Y-m-d H:i:s'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\n"</span>;</span><br><span class="line"><span class="variable">$date2</span> = <span class="keyword">new</span> DateTime(<span class="string">'tomorrow'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$date2</span>-&gt;format(<span class="string">'Y-m-d H:i:s'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\n"</span>;</span><br><span class="line"><span class="variable">$date2</span> = <span class="keyword">new</span> DateTime(<span class="string">'+2 days'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$date2</span>-&gt;format(<span class="string">'Y-m-d H:i:s'</span>);</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>执行结果为：
2014-05-04 00:00:00
2014-08-26 00:00:00
2014-08-27 13:13:34</p>
</blockquote>
<p>或则通过DateTime的其他方法</p>
<p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="variable">$date</span> = <span class="keyword">new</span> DateTime();</span><br><span class="line"><span class="comment">// add方法</span></span><br><span class="line"><span class="variable">$date</span>-&gt;add(<span class="keyword">new</span> DateInterval(<span class="string">'P1D'</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$date</span>-&gt;format(<span class="string">'Y-m-d H:i:s'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\n"</span>;</span><br><span class="line"><span class="comment">// modify方法</span></span><br><span class="line"><span class="variable">$date</span>-&gt;modify(<span class="string">'+1 day'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$date</span>-&gt;format(<span class="string">'Y-m-d H:i:s'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\n"</span>;</span><br><span class="line"><span class="comment">// setDate方法</span></span><br><span class="line"><span class="variable">$date</span>-&gt;setDate(<span class="string">'1989-11-10'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$date</span>-&gt;format(<span class="string">'Y-m-d H:i:s'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\n"</span>;</span><br><span class="line"><span class="comment">// setTime方法</span></span><br><span class="line"><span class="variable">$date</span>-&gt;setTime(<span class="string">'11:10:10'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$date</span>-&gt;format(<span class="string">'Y-m-d H:i:s'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\n"</span>;</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>执行结果分别为：
2014-08-26 15:02:57
2014-08-27 15:02:57
1989-11-10 15:02:57
1989-11-10 11:10:10</p>
</blockquote>
<h2>3. unix时间戳的转换</h2>
<h3>获取当前时间的时间戳</h3>
<p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="variable">$date</span> = <span class="keyword">new</span> DateTime();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$date</span>-&gt;format(<span class="string">'U'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\n"</span>;</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>执行结果为：1408950651</p>
</blockquote>
<p>或者</p>
<p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="variable">$date</span> = <span class="keyword">new</span> DateTime();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$date</span>-&gt;getTimestamp();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\n"</span>;</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3>将时间戳转换为可读时间</h3>
<p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="variable">$date</span> = <span class="keyword">new</span> DateTime(<span class="string">'@1408950651'</span>);</span><br><span class="line"><span class="variable">$date</span>-&gt;setTimezone(<span class="keyword">new</span> DateTimeZone(<span class="string">'Asia/Shanghai'</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$date</span>-&gt;format(<span class="string">'Y-m-d H:i:s'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\n"</span>;</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>执行结果为：2014-08-25 15:10:51</p>
</blockquote>
<p>或者</p>
<p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="variable">$date</span> = <span class="keyword">new</span> DateTime();</span><br><span class="line"><span class="variable">$date</span>-&gt;setTimestamp(<span class="number">1408950651</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$date</span>-&gt;format(<span class="string">'Y-m-d H:i:s'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\n"</span>;</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2>4. 日期的比较</h2>
<h3>日期大小比较</h3>
<p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="variable">$date1</span> = <span class="keyword">new</span> DateTime();</span><br><span class="line"><span class="variable">$date2</span> = <span class="keyword">new</span> DateTime(<span class="string">'2014-09-15'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$date1</span> &lt; <span class="variable">$date2</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$date2</span>-&gt;format(<span class="string">'Y-m-d H:i:s'</span>) . <span class="string">' is in the future'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3>日期间隔</h3>
<p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="variable">$date1</span> = <span class="keyword">new</span> DateTime();</span><br><span class="line"><span class="variable">$date2</span> = <span class="keyword">new</span> DateTime(<span class="string">'2014-09-15'</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$diff</span> = <span class="variable">$date1</span>-&gt;diff(<span class="variable">$date2</span>);</span><br><span class="line">print_r(<span class="variable">$diff</span>);</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>执行结果为:
DateInterval Object
(
[y] =&gt; 0
[m] =&gt; 0
[d] =&gt; 20
[h] =&gt; 7
[i] =&gt; 35
[s] =&gt; 50
[weekday] =&gt; 0
[weekday_behavior] =&gt; 0
[first_last_day_of] =&gt; 0
[invert] =&gt; 0
[days] =&gt; 20
[special_type] =&gt; 0
[special_amount] =&gt; 0
[have_weekday_relative] =&gt; 0
[have_special_relative] =&gt; 0
)</p>
</blockquote>
<p>将返回的对象格式化输出</p>
<p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="variable">$date1</span> = <span class="keyword">new</span> DateTime();</span><br><span class="line"><span class="variable">$date2</span> = <span class="keyword">new</span> DateTime(<span class="string">'2014-09-15'</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$diff</span> = <span class="variable">$date1</span>-&gt;diff(<span class="variable">$date2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$diff</span>-&gt;format(<span class="string">"The future will come in %Y years %m months and %d days"</span>);</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>输出结果为：The future will come in 00 years 0 months and 20 days</p>
</blockquote>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/PHP/class-datetime-in-php.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[解决ssh到ubuntu server卡顿]]></title>
      <link>http://yaxin-cn.github.io/Linux/solve-ssh-slow-to-ubuntu.html</link>
      <guid>http://yaxin-cn.github.io/Linux/solve-ssh-slow-to-ubuntu.html</guid>
      <pubDate>Tue, 08 Jul 2014 12:15:34 GMT</pubDate>
      <description>
      <![CDATA[<p>ssh到ubuntu14.04卡的要死，google一下无非是修改<strong>sshd_config</strong>文件中的<code>GSSAPIAuthentication</code>和<code>UseDNS</code>选项，但依然无济于事。</p>
<p>]]>
      </description>
      <content:encoded><![CDATA[<p>ssh到ubuntu14.04卡的要死，google一下无非是修改<strong>sshd_config</strong>文件中的<code>GSSAPIAuthentication</code>和<code>UseDNS</code>选项，但依然无济于事。</p>
<p>使用<code>-v</code>参数（可以输出ssh详细过程）ssh发现卡顿是发生在输入密码之后的</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yaxin@<span class="number">192.168</span>.<span class="number">1.1</span><span class="string">'s password:</span><br><span class="line">debug1: Authentication succeeded (password).</span><br><span class="line">debug1: channel 0: new [client-session]</span><br><span class="line">debug1: Requesting no-more-sessions@openssh.com</span><br><span class="line">debug1: Entering interactive session. # 卡一段时间</span></span><br></pre></td></tr></table></figure></p>
<p>这说明进入交互式终端的时候卡了，再来看登录后</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Welcome to Ubuntu <span class="number">14.04</span> LTS (GNU/Linux <span class="number">3.13</span>.<span class="number">0</span>-<span class="number">24</span>-generic x86_64)</span><br><span class="line">......</span><br><span class="line"><span class="number">62</span> packages can be updated.</span><br><span class="line"><span class="number">43</span> updates are security updates.</span><br><span class="line"></span><br><span class="line">Last login: Tue Jul  <span class="number">8</span> <span class="number">20</span>:<span class="number">29</span>:<span class="number">20</span> <span class="number">2014</span> from <span class="number">192.168</span>.<span class="number">1.5</span></span><br></pre></td></tr></table></figure></p>
<p>上面的内容在其它版本中为<code>/etc/motd</code>中的内容，但ubuntu是动态生成该内容，生成脚本在<code>/etc/update-motd.d</code>目录下，查看脚本可以是联网检测系统更新等情况。呵呵，如何禁用。</p>
<p>修改<code>/etc/pam.d/sshd</code>和<code>/etc/pam.d/login</code>文件中的有<strong>pam_motd.so</strong>的行注释掉</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#session    optional     pam_motd.so  motd=/run/motd.dynamic noupdate</span></span><br><span class="line"><span class="comment">#session    optional     pam_motd.so # [1]</span></span><br></pre></td></tr></table></figure></p>
<p>再次ssh，这次没有了上面的update等信息了，但ssh也不卡顿了。</p>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Linux/solve-ssh-slow-to-ubuntu.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Docker中搭建开发环境1]]></title>
      <link>http://yaxin-cn.github.io/Docker/setup-development-enviroment-in-docker-1.html</link>
      <guid>http://yaxin-cn.github.io/Docker/setup-development-enviroment-in-docker-1.html</guid>
      <pubDate>Fri, 04 Jul 2014 05:06:58 GMT</pubDate>
      <description>
      <![CDATA[<p>由于docker有很好的隔离性，所以开发使用最适合不过。windows下配合**<a href="https://github.com/boot2docker/windows-installer/releases" target="_blank" rel="external]]>
      </description>
      <content:encoded><![CDATA[<p>由于docker有很好的隔离性，所以开发使用最适合不过。windows下配合**<a href="https://github.com/boot2docker/windows-installer/releases" target="_blank" rel="external">boot2docker</a>**轻松击败重量级虚拟机。</p>
<p>由于是开发环境，我们首先需要将docker container开启ssh服务，以便随时登录到上面查看修改配置，之后再去搭建真正的开发环境。所以我们可以先创建一个开启了ssh服务的image来作为base image，然后在它的基础之上搭建不通的开发环境。</p>
<p>创建镜像需要使用到Dockerfile，Dockerfile的具体语法可以到<a href="http://docker-docs.qiniudn.com/reference/builder/" title="Dockerfile文档" target="_blank" rel="external">官网</a>去查看，这里不详细介绍。</p>
<p>先上<em>Dockerfile</em>内容：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sshd</span></span><br><span class="line"><span class="comment"># VERSION 1.0.0</span></span><br><span class="line"></span><br><span class="line">FROM ubuntu:<span class="number">14.04</span></span><br><span class="line">MAINTAINER yaxin &lt;yaxin.me@gmail.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># make sure the package repository is up to date</span></span><br><span class="line">RUN sed -i <span class="string">"s/archive.ubuntu.com/mirrors.aliyun.com/g"</span> /etc/apt/sources.list</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y openssh-server</span><br><span class="line"><span class="comment"># Config ssh server</span></span><br><span class="line">RUN mkdir -p /var/run/sshd</span><br><span class="line">RUN sed -i <span class="string">"s/^PermitRootLogin without-password/PermitRootLogin yes/g"</span> /etc/ssh/sshd_config</span><br><span class="line">RUN sed -i <span class="string">"s/^#GSSAPIAuthentication no/GSSAPIAuthentication no/g"</span> /etc/ssh/sshd_config</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">"UseDNS no"</span> &gt;&gt; /etc/ssh/sshd_config</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">'root:root'</span> | chpasswd</span><br><span class="line"></span><br><span class="line">EXPOSE <span class="number">22</span></span><br><span class="line">CMD [<span class="string">"/usr/sbin/sshd"</span>, <span class="string">"-D"</span>]</span><br></pre></td></tr></table></figure></p>
<p>新建文件夹并将上面的代码保存为以<strong>Dockerfile</strong>命名的文本文件。</p>
<p>然后执行</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@ubox sshd]<span class="variable">$ls</span></span><br><span class="line">Dockerfile</span><br><span class="line">[yaxin@ubox sshd]<span class="variable">$docker</span> build -t ubuntu:base .</span><br></pre></td></tr></table></figure></p>
<p>来创建镜像。下面来稍微解释一下Dockerfile的内容</p>
<h3>FROM</h3>
<p>必须是Dockerfile的第一句，之后的操作都是在这个镜像之上进行的。如果你没有，那要先下载，<code>docker pull ubuntu</code>，如果无法下载，翻墙吧。如果你有国外vps，那么你可以在vps上<code>docker pull ubuntu</code>下载该镜像然后<code>docker save ubuntu:14.04 | bzip2 -9 -c &gt; ubuntu_14.04.tar.bz2</code>，然后下载ubuntu_14.04.tar.bz2到本机，运行<code>bzip2 -d -c &lt; ubuntu_14.04.tar.bz2 | docker load</code>导入镜像，我就是这么干的。</p>
<h3>RUN</h3>
<p>执行shell命令。</p>
<h3>ADD</h3>
<p>将外部文件导入到镜像中。</p>
<h3>EXPOSE</h3>
<p>将22端口‘暴漏’出来，以便在外部访问该端口。没有的话，将无法从外部（非运行docker的主机）ssh。</p>
<h3>CMD</h3>
<p>跟<code>RUN</code>一样，也是执行shell命令，不同的是<code>RUN</code>是在创建镜像的时候执行，而<code>CMD</code>是在每次执行<code>docker run image</code>的时候执行。</p>
<p>build完镜像后，我们执行<code>docker images</code>会发现多了一个镜像</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@ubox sshd]<span class="variable">$docker</span> images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu              base                <span class="number">615</span>ea4d4c1e0        <span class="number">2</span> weeks ago         <span class="number">396.4</span> MB</span><br><span class="line">ubuntu              <span class="number">14.04</span>               ad892dd21d60        <span class="number">4</span> weeks ago         <span class="number">275.5</span> MB</span><br></pre></td></tr></table></figure></p>
<p>然后启动镜像</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@ubox sshd]<span class="variable">$docker</span> run <span class="operator">-d</span> -P --name=<span class="string">"sshd"</span> ubuntu:base</span><br><span class="line">c2518b7cf9289567c258171e93462bdb7fffe873bf2251d7086<span class="built_in">cd</span>97e03e3ee57</span><br><span class="line">[yaxin@ubox sshd]<span class="variable">$docker</span> ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                   NAMES</span><br><span class="line">c2518b7cf928        ubuntu:base         /usr/sbin/sshd -D      <span class="number">4</span> seconds ago       Up <span class="number">3</span> seconds        <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">49153</span>-&gt;<span class="number">22</span>/tcp   sshd</span><br></pre></td></tr></table></figure></p>
<p>然后ssh 49153端口</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@ubox sshd]<span class="variable">$ssh</span> root@localhost -p <span class="number">49153</span></span><br><span class="line">The authenticity of host <span class="string">'[localhost]:49153 ([::1]:49153)'</span> can<span class="string">'t be established.</span><br><span class="line">ECDSA key fingerprint is c4:a5:26:07:8b:72:97:40:f2:42:fa:35:9a:7c:d0:79.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added '</span>[localhost]:<span class="number">49153</span><span class="string">' (ECDSA) to the list of known hosts.</span><br><span class="line">root@localhost'</span>s password: </span><br><span class="line">Welcome to Ubuntu <span class="number">14.04</span> LTS (GNU/Linux <span class="number">3.2</span>.<span class="number">0</span>-<span class="number">58</span>-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com/</span><br><span class="line"></span><br><span class="line">The programs included with the Ubuntu system are free software;</span><br><span class="line">the exact distribution terms <span class="keyword">for</span> each program are described <span class="keyword">in</span> the</span><br><span class="line">individual files <span class="keyword">in</span> /usr/share/doc/*/copyright.</span><br><span class="line"></span><br><span class="line">Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by</span><br><span class="line">applicable law.</span><br><span class="line"></span><br><span class="line">root@c2518b7cf928:~<span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>自此，一个装有ssh服务的可以运行的base image就创建成功了。</p>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Docker/setup-development-enviroment-in-docker-1.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[icmp包检验和计算方法及python实现]]></title>
      <link>http://yaxin-cn.github.io/Python/icmp-packet-checksum-with-python.html</link>
      <guid>http://yaxin-cn.github.io/Python/icmp-packet-checksum-with-python.html</guid>
      <pubDate>Fri, 30 May 2014 06:24:01 GMT</pubDate>
      <description>
      <![CDATA[<p>发送icmp包时，需要计算icmp包的校验和，与ip包不同的是，icmp包需要连通头部信息加数据本身一起进行校验（ip包只需要校验头部信息）</p>
<p>校验方法如下：</p>
<ol>
<li>把校验和字段置为0</li>
<li>将icmp包（包括header和dat]]>
      </description>
      <content:encoded><![CDATA[<p>发送icmp包时，需要计算icmp包的校验和，与ip包不同的是，icmp包需要连通头部信息加数据本身一起进行校验（ip包只需要校验头部信息）</p>
<p>校验方法如下：</p>
<ol>
<li>把校验和字段置为0</li>
<li>将icmp包（包括header和data）以16bit（2个字节）为一组，并将所有组相加（二进制求和）</li>
<li>若高16bit不为0，则将高16bit与低16bit反复相加，直到高16bit的值为0，从而获得一个只有16bit长度的值</li>
<li>将此16bit值进行按位求反操作，将所得值替换到校验和字段</li>
</ol>
<p><strong>注意</strong>: 第四步中的<em>按位求反</em>值C语言的的<em>按位求反</em>（即~操作符），不是python中的<em>按位求反</em></p>
<p>例如下图中的icmp包：</p>
<p><img src="//cube2x-blog.qiniudn.com/blog-img/icmp_data.png" alt="icmp抓包截图"></p>
<p>其中icmp包的内容为：</p>
<blockquote>
<p>08 00 F9 CE 7C E2 01 00 20 28 20 52 64 77 6A 6D 58 67 65 42 5A 2A 61 64 52 41 44 78 75 40 35 28 6F 76 20 43 56 76 59 20 4E 4F 64 20 20 6B 75 64 40 72 31 4A 50 20 20 33 67 20 2B 31 2A 51 20 52 70</p>
</blockquote>
<p>校验字段为<strong>F9 CE</strong></p>
<p>将校验字段置为0，然后以16bit为一组将全部字段二进制相加，即：</p>
<p>0800 + 0000 + 7CE2 + 0100 + 2028 + 2052 + 6477 + 6A6D + 5867 + 6542 + 5A2A + 6164 + 5241 + 4478 + 7540 + 3528 + 6F76 + 2043 + 5676 + 5920 + 4E4F + 6420 + 206B + 7564 + 4072 + 314A + 5020 + 2033 + 6720 + 2B31 + 2A51 + 2052 + 70 = 930fd</p>
<p><strong>注意该数据的长度并不是16bit的整数倍，计算方式一样，只不过将最后8bit直接与之前相加</strong></p>
<p>然后将结果的高16bit和低16bit继续相加：</p>
<p>0009 + 30fd = 3106</p>
<p>然后对结果（3106）进行c语言的<em>按位求反</em>操作（C语言的按位求反）：</p>
<p>~3106 =&gt; CEF9</p>
<p><em><em>C语言的</em>按位求反</em>是让操作数的二进制位上的1变为0，0变为1， 而python的<em>按位求反</em>这是将操作数加一然后乘以负一（~5 == -6），两者之所以出现不同就在于操作数是否是unsigned**</p>
<p>附上最后的程序（注意一下如何将python的<em>按位求反</em>转为C语言的<em>按位求反</em>）</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checksum</span><span class="params">(data)</span>:</span></span><br><span class="line">    length = len(data)</span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    n = length % <span class="number">2</span></span><br><span class="line">    <span class="comment"># 分割数据每两比特(16bit)为一组</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, length - n, <span class="number">2</span>):</span><br><span class="line">        s += ord(data[i]) + (ord(data[i+<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">    <span class="comment"># 如果数据长度为基数,则将最后一位单独相加</span></span><br><span class="line">    <span class="keyword">if</span> n:</span><br><span class="line">        s += ord(data[-<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 重复将高16位与低16位相加直到高16位为0</span></span><br><span class="line">    <span class="keyword">while</span> (s &gt;&gt; <span class="number">16</span>):</span><br><span class="line">        s = (s &amp; <span class="number">0xFFFF</span>) + (s &gt;&gt; <span class="number">16</span>)</span><br><span class="line">    s = ~s &amp; <span class="number">0xffff</span></span><br><span class="line">    <span class="comment"># 返回的是十进制整数</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure></p>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Python/icmp-packet-checksum-with-python.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[理解Python中数值和字符串对象是不可变化的]]></title>
      <link>http://yaxin-cn.github.io/Python/understand-python-string-objects-are-immutable.html</link>
      <guid>http://yaxin-cn.github.io/Python/understand-python-string-objects-are-immutable.html</guid>
      <pubDate>Mon, 19 May 2014 13:11:32 GMT</pubDate>
      <description>
      <![CDATA[<p>在Python中数值和字符串对象是不可以改变的，但对于新手的我们很难理解，于是乎会有下面的代码:</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="li]]>
      </description>
      <content:encoded><![CDATA[<p>在Python中数值和字符串对象是不可以改变的，但对于新手的我们很难理解，于是乎会有下面的代码:</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="string">'Hello World'</span></span><br><span class="line"><span class="keyword">print</span> x</span><br><span class="line">x = <span class="string">'Hello Hello'</span></span><br><span class="line"><span class="keyword">print</span> x</span><br></pre></td></tr></table></figure></p>
<p>上面的代码明显的说明了变量<code>x</code>是可以改变的。其实变量<code>x</code>的改变伴随着<code>x</code>内存地址的变化，也就是说系统重新创建了一个名为<strong>x</strong>的变量用于保存新字符串。想要证明这个需要用到Python的<code>id</code>函数。</p>
<p>id函数返回一个数字，这个数字跟该对象的分配内存地址密切相关。也可以近似认为这个数值就是该对象（变量）的所在内存地址。</p>
<blockquote>
<p>python中id函数的说明
Help on built-in function id in module <strong>builtin</strong>:</p>
<p>id(...)
id(object) -&gt; integer</p>
<p>Return the identity of an object.  This is guaranteed to be unique among
simultaneously existing objects.  (Hint: it's the object's memory address.)</p>
</blockquote>
<p>现在再来看下面的代码：</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="string">'Hello World'</span></span><br><span class="line"><span class="keyword">print</span> id(x)</span><br><span class="line">x = <span class="string">'Hello Hello'</span></span><br><span class="line"><span class="keyword">print</span> id(x)</span><br><span class="line">y = [<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line"><span class="keyword">print</span> id(y)</span><br><span class="line">y.append(<span class="string">'c'</span>)</span><br><span class="line"><span class="keyword">print</span> id(y)</span><br></pre></td></tr></table></figure></p>
<p>你运行结果如下：</p>
<blockquote>
<p>21908576
21906752
23032176
23032176</p>
</blockquote>
<p>可以看出前两个<code>id</code>的结果并不相同，而后面的两个（python中列表、字典对象是可变的）结果却是一样的，这说明字符串对象在python中是不可变的，即使重新对变量赋值，也只是重新生成相同变量的字符串而并不是直接改变当前的字符串变量。</p>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Python/understand-python-string-objects-are-immutable.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[docker中如何删除image（镜像）]]></title>
      <link>http://yaxin-cn.github.io/Docker/how-to-delete-a-docker-image.html</link>
      <guid>http://yaxin-cn.github.io/Docker/how-to-delete-a-docker-image.html</guid>
      <pubDate>Sat, 22 Mar 2014 07:46:29 GMT</pubDate>
      <description>
      <![CDATA[<p>docker中删除images的命令是<code>docker rmi</code>，但有时候执行此命令并不能删除images</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><s]]>
      </description>
      <content:encoded><![CDATA[<p>docker中删除images的命令是<code>docker rmi</code>，但有时候执行此命令并不能删除images</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@ubox ~]<span class="variable">$docker</span> images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">eg_sshd             latest              ed9c93747fe1        <span class="number">45</span> hours ago        <span class="number">329.8</span> MB</span><br><span class="line">CentOS65            latest              e55a74a32125        <span class="number">2</span> days ago          <span class="number">360.6</span> MB</span><br><span class="line">[yaxin@ubox ~]<span class="variable">$docker</span> rmi ed9c93747fe1</span><br><span class="line">Untagged: ed9c93747fe16627be822ad3f7feeb8b4468200e5357877d3046aa83cc44c6af</span><br><span class="line">[yaxin@ubox ~]<span class="variable">$docker</span> images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              ed9c93747fe1        <span class="number">45</span> hours ago        <span class="number">329.8</span> MB</span><br><span class="line">CentOS65            latest              e55a74a32125        <span class="number">2</span> days ago          <span class="number">360.6</span> MB</span><br></pre></td></tr></table></figure></p>
<p>可以看出，image并没有被删除，只是他的tag被删除了，再次执行<code>docker rmi IMAGE_ID</code>只会报错</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@ubox ~]<span class="variable">$docker</span> rmi ed9c93747fe1</span><br><span class="line">Error: image_delete: Conflict, ed9c93747fe1 wasn<span class="string">'t deleted</span><br><span class="line">2014/03/22 15:58:27 Error: failed to remove one or more images</span></span><br></pre></td></tr></table></figure></p>
<p>查看docker的帮助会发现有两个与删除有关的命令<code>rm</code>和<code>rmi</code></p>
<blockquote>
<p>rm        Remove one or more containers<br>
rmi       Remove one or more images</p>
</blockquote>
<p>这里有两个不同的单词，<strong>images</strong>和<strong>container</strong>。其中images很好理解，跟平常使用的虚拟机的镜像一个意思，相当于一个模版，而container则是images运行时的的状态。docker对于运行过的image都保留一个状态（container），可以使用命令<code>docker ps</code>来查看正在运行的container，对于已经退出的container，则可以使用<code>docker ps -a</code>来查看。 如果你退出了一个container而忘记保存其中的数据，你可以使用<code>docker ps -a</code>来找到对应的运行过的container使用<code>docker commit</code>命令将其保存为image然后运行。</p>
<p>回到之前的问题，由于image被某个container引用（拿来运行），如果不将这个引用的container销毁（删除），那image肯定是不能被删除。</p>
<p>所以想要删除运行过的images必须首先删除它的container。继续来看刚才的例子，</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@ubox ~]<span class="variable">$docker</span> ps <span class="operator">-a</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                   NAMES</span><br><span class="line"><span class="number">117843</span>ade696        ed9c93747fe1        /bin/sh -c /usr/sbin   <span class="number">46</span> hours ago        Up <span class="number">46</span> hours         <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">49153</span>-&gt;<span class="number">22</span>/tcp   <span class="built_in">test</span>_sshd</span><br></pre></td></tr></table></figure></p>
<p>可以看出<strong>ed9c93747fe1</strong>的image被<strong>117843ade696</strong>的container使用着，所以必须首先删除该container</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@ubox ~]<span class="variable">$docker</span> rm <span class="number">117843</span>ade696</span><br><span class="line">Error: container_delete: Impossible to remove a running container, please stop it first</span><br><span class="line"><span class="number">2014</span>/<span class="number">03</span>/<span class="number">22</span> <span class="number">16</span>:<span class="number">36</span>:<span class="number">44</span> Error: failed to remove one or more containers</span><br></pre></td></tr></table></figure></p>
<p>出现错误，这是因为该container正在运行中(运行<code>docker ps</code>查看)，先将其关闭</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@ubox ~]<span class="variable">$docker</span> stop <span class="number">117843</span>ade696</span><br><span class="line"><span class="number">117843</span>ade696</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@ubox ~]<span class="variable">$docker</span> rm <span class="number">117843</span>ade696</span><br><span class="line"><span class="number">117843</span>ade696</span><br><span class="line">[yaxin@ubox ~]<span class="variable">$docker</span> rmi ed9c93747fe1</span><br><span class="line">Deleted: ed9c93747fe16627be822ad3f7feeb8b4468200e5357877d3046aa83cc44c6af</span><br><span class="line">Deleted: c8a0c19429daf73074040a14e527ad5734e70363c644f18c6815388b63eedc9b</span><br><span class="line">Deleted: <span class="number">95</span>dba4c468f0e53e5f1e5d76b8581d6740aab9f59141f783f8e263ccd7cf2a8e</span><br><span class="line">Deleted: c25dc743e40af6858c34375d450851bd606a70ace5d04e231a7fcc6d2ea23cc1</span><br><span class="line">Deleted: <span class="number">20562</span>f5714a5ce764845119399ef75e652e23135<span class="built_in">cd</span>5c54265ff8218b61ccbd33</span><br><span class="line">Deleted: c8af1dc23af7a7aea0c25ba9b28bdee68caa8866f056e4f2aa2a5fa1bcb12693</span><br><span class="line">Deleted: <span class="number">38</span>fdb2c5432e08ec6121f8dbb17e1fde17d5db4c1f149a9b702785dbf7b0f3be</span><br><span class="line">Deleted: <span class="number">79</span>ca14274c80ac1df1333b89b2a41c0e0e3b91<span class="built_in">cd</span>1b267b31bef852ceab3b2044</span><br><span class="line">[yaxin@ubox ~]<span class="variable">$docker</span> images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">CentOS65            latest              e55a74a32125        <span class="number">2</span> days ago          <span class="number">360.6</span> MB</span><br></pre></td></tr></table></figure></p>
<p>可以看出，image已经被删除。</p>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Docker/how-to-delete-a-docker-image.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[shell实现输入密码显示星号]]></title>
      <link>http://yaxin-cn.github.io/Linux/replace-password-with-stars-under-shell.html</link>
      <guid>http://yaxin-cn.github.io/Linux/replace-password-with-stars-under-shell.html</guid>
      <pubDate>Sat, 07 Sep 2013 07:02:48 GMT</pubDate>
      <description>
      <![CDATA[<p>shell脚本可以使用read -s来默认禁止回显输入字符，这样做一定程度上可以保证安全性。但这并不是一个好的交互，因为对于输入密码并不能知道已经输入了多少个字符。而使用*（星号）来代替输入的字符是一个很不错的想法，即保证安全又有好的交互性。</p>
<p>程序的实现</p]]>
      </description>
      <content:encoded><![CDATA[<p>shell脚本可以使用read -s来默认禁止回显输入字符，这样做一定程度上可以保证安全性。但这并不是一个好的交互，因为对于输入密码并不能知道已经输入了多少个字符。而使用*（星号）来代替输入的字符是一个很不错的想法，即保证安全又有好的交互性。</p>
<p>程序的实现</p>
<p>首先要实现不显示输入字符，这个可以使用命令stty来实现</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">stty cbreak -echo</span><br><span class="line">dd <span class="keyword">if</span>=/dev/tty bs=<span class="number">1</span> count=<span class="number">1</span> <span class="number">2</span>&gt;/dev/null</span><br><span class="line">stty -cbreak <span class="built_in">echo</span></span><br></pre></td></tr></table></figure></p>
<p>运行上面的命令（放在脚本中），可以发现输入一个字符并不会在屏幕上显示出来，这是因为<code>stty -echo</code>会禁止回显，而<code>dd if=/dev/tty bs=1 count=1 2&gt;/dev/null</code>则是获取刚刚输入的字符，如果将上面的命令放在$()中运行，并将其赋值给变量，打印会发现就是刚刚输入的字符。</p>
<p>由于上面的命令只是接收一个字符，要多个字符的话需要使用while语句来实现，然后通过判断输入的字符是否为回车键来实现结束输入。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> : ;<span class="keyword">do</span></span><br><span class="line">    char=`</span><br><span class="line">        stty cbreak -echo</span><br><span class="line">        dd <span class="keyword">if</span>=/dev/tty bs=<span class="number">1</span> count=<span class="number">1</span> <span class="number">2</span>&gt;/dev/null</span><br><span class="line">        stty -cbreak <span class="built_in">echo</span></span><br><span class="line">    `</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$char</span>"</span> =  <span class="string">""</span> ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    password=<span class="string">"<span class="variable">$password</span><span class="variable">$char</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>然后我们来实现输出为星号。这个很简单，上面的程序在整个过程中不会输出任何字符，要实现输出只需要在每次while循环的结束输出一个*即可。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> : ;<span class="keyword">do</span></span><br><span class="line">    char=`</span><br><span class="line">        stty cbreak -echo</span><br><span class="line">        dd <span class="keyword">if</span>=/dev/tty bs=<span class="number">1</span> count=<span class="number">1</span> <span class="number">2</span>&gt;/dev/null</span><br><span class="line">        stty -cbreak <span class="built_in">echo</span></span><br><span class="line">    `</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$char</span>"</span> =  <span class="string">""</span> ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    password=<span class="string">"<span class="variable">$password</span><span class="variable">$char</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"*"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>OK，全部实现完毕，密码存在password变量中。</p>
<p>错误解决</p>
<p>但在运行中会发现，按删除（backspace）不会减少个数，反而增加了。直接运行read命令，然后按backspace键，会发现输出了“^H”，这是因为backspace并未绑定为删除功能，需要在脚本中添加<code>stty erase &quot;^H&quot;</code>来解决这一问题。但此时问题还是存在，原因在于backspace也是一个按键，而while中的判断并未判断按键为backspace的情况，因而程序会运行到输出一行。解决的方法就是在while中判断backspace按键并进行相应的操作。</p>
<p>首先是判断backspace按键，获取backspace按键的方法有两种：第一种是使用子shell输出backspace的转义字符即<code>$(echo -ne &quot;\b&quot;)</code>、第二种是利用vim，先按ctrl+v然后再backspace，就会输出backspace的标志。</p>
<p>然后是删除之前的一个字符，这里使用shell的ANSI控制码，首先将光标前移一个字符<code>printf &quot;33[1D&quot;</code>，然后删除光标之后的字符<code>printf &quot;33[K&quot;</code>，当然，还要将最后一个字符从password变量中移除。</p>
<p>最后完整的程序应该是：</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> : ;<span class="keyword">do</span></span><br><span class="line">    char=`</span><br><span class="line">        stty cbreak -echo</span><br><span class="line">        dd <span class="keyword">if</span>=/dev/tty bs=<span class="number">1</span> count=<span class="number">1</span> <span class="number">2</span>&gt;/dev/null</span><br><span class="line">        stty -cbreak <span class="built_in">echo</span></span><br><span class="line">    `</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$char</span>"</span> =  <span class="string">""</span> ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">"<span class="variable">$ret</span>"</span> == $(<span class="built_in">echo</span> <span class="operator">-ne</span> <span class="string">'\b'</span>) ]];<span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$x</span> <span class="operator">-eq</span> <span class="number">0</span> ];<span class="keyword">then</span></span><br><span class="line">            <span class="built_in">continue</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        password=<span class="string">"<span class="variable">$&#123;password%?&#125;</span>"</span></span><br><span class="line">        <span class="built_in">printf</span> <span class="string">"33[1D"</span></span><br><span class="line">        <span class="built_in">printf</span> <span class="string">"33[K"</span></span><br><span class="line">        <span class="built_in">let</span> x--</span><br><span class="line">        <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    password=<span class="string">"<span class="variable">$password</span><span class="variable">$char</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"*"</span></span><br><span class="line">    <span class="built_in">let</span> x++</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Linux/replace-password-with-stars-under-shell.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[未知元素高度情况下使其垂直居中方案]]></title>
      <link>http://yaxin-cn.github.io/front-end/make-element-vertical-center-with-css.html</link>
      <guid>http://yaxin-cn.github.io/front-end/make-element-vertical-center-with-css.html</guid>
      <pubDate>Sun, 23 Dec 2012 02:06:56 GMT</pubDate>
      <description>
      <![CDATA[<p>一直以来都是使用<a href="http://xinmu.me/blog" target="_blank" rel="external">xinmu.me/blog</a>作为博客的首页，而<a href="http://xinmu.me" target="_blank"]]>
      </description>
      <content:encoded><![CDATA[<p>一直以来都是使用<a href="http://xinmu.me/blog" target="_blank" rel="external">xinmu.me/blog</a>作为博客的首页，而<a href="http://xinmu.me" target="_blank" rel="external">xinmu.me</a>则一直荒废着。今天忽然想起了它，便想着先放一个链接上去，一个链接还是居中的好（浏览器正中央）。上网搜了各种方法，都需要知道元素的高度才可以，遂上SegmentFault（一个很好的地方）提问，得到了大神神飞的帮助，解决了问题，下面只是将解决办法复制、粘贴一下，原问题在此<a href="http://segmentfault.com/q/1010000000153017" target="_blank" rel="external">http://segmentfault.com/q/1010000000153017</a></p>
<p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"Content-Type"</span> <span class="attribute">content</span>=<span class="value">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">title</span>&gt;</span>只是文字的水平和垂直居中<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span><br><span class="line"><span class="tag">html</span>,<span class="tag">body</span><span class="rules">&#123;<span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;<span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100%</span></span></span>;<span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span></span></span>;<span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span>&#125;</span><br><span class="line">body&#123;background-color: green</span></span>;<span class="rule"><span class="attribute">display</span>:<span class="value"> table</span></span>;&#125;</span></span><br><span class="line"><span class="tag">p</span><span class="rules">&#123;<span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">1.6</span></span></span>;<span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;<span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>;<span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span></span></span>;<span class="rule"><span class="attribute">display</span>:<span class="value"> table-cell</span></span>;<span class="rule"><span class="attribute">vertical-align</span>:<span class="value"> middle</span></span>;&#125;</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">true<span class="tag">&lt;<span class="title">p</span>&gt;</span>wording<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/front-end/make-element-vertical-center-with-css.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Linux下查看网卡MAC地址]]></title>
      <link>http://yaxin-cn.github.io/Linux/check-mac-address-under-linux.html</link>
      <guid>http://yaxin-cn.github.io/Linux/check-mac-address-under-linux.html</guid>
      <pubDate>Tue, 18 Dec 2012 01:56:51 GMT</pubDate>
      <description>
      <![CDATA[<h2>方法一：使用ifconfig命令</h2>
<p>直接在命令行中ifconfig，即可看到所有已连接网线（已经激活的网卡）的网卡信息</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pr]]>
      </description>
      <content:encoded><![CDATA[<h2>方法一：使用ifconfig命令</h2>
<p>直接在命令行中ifconfig，即可看到所有已连接网线（已经激活的网卡）的网卡信息</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@oishi ~]<span class="variable">$ifconfig</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr <span class="number">00</span>:<span class="number">50</span>:<span class="number">56</span>:AC:<span class="number">57</span>:<span class="number">30</span>  </span><br><span class="line">          inet addr:<span class="number">10.10</span>.<span class="number">8.110</span>  Bcast:<span class="number">10.10</span>.<span class="number">8.255</span>  Mask:<span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:<span class="number">1500</span>  Metric:<span class="number">1</span></span><br><span class="line">          RX packets:<span class="number">11645825</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> frame:<span class="number">0</span></span><br><span class="line">          TX packets:<span class="number">9430946</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> carrier:<span class="number">0</span></span><br><span class="line">          collisions:<span class="number">0</span> txqueuelen:<span class="number">1000</span> </span><br><span class="line">          RX bytes:<span class="number">2446979632</span> (<span class="number">2.2</span> GiB)  TX bytes:<span class="number">1937455163</span> (<span class="number">1.8</span> GiB)</span><br><span class="line"></span><br><span class="line">eth0:<span class="number">1</span>    Link encap:Ethernet  HWaddr <span class="number">00</span>:<span class="number">50</span>:<span class="number">56</span>:AC:<span class="number">57</span>:<span class="number">30</span>  </span><br><span class="line">          inet addr:<span class="number">10.10</span>.<span class="number">8.10</span>  Bcast:<span class="number">10.10</span>.<span class="number">8.255</span>  Mask:<span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:<span class="number">1500</span>  Metric:<span class="number">1</span></span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:<span class="number">127.0</span>.<span class="number">0.1</span>  Mask:<span class="number">255.0</span>.<span class="number">0.0</span></span><br><span class="line">          UP LOOPBACK RUNNING  MTU:<span class="number">16436</span>  Metric:<span class="number">1</span></span><br><span class="line">          RX packets:<span class="number">12722</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> frame:<span class="number">0</span></span><br><span class="line">          TX packets:<span class="number">12722</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> carrier:<span class="number">0</span></span><br><span class="line">          collisions:<span class="number">0</span> txqueuelen:<span class="number">0</span> </span><br><span class="line">          RX bytes:<span class="number">710416</span> (<span class="number">693.7</span> KiB)  TX bytes:<span class="number">710416</span> (<span class="number">693.7</span> KiB)</span><br></pre></td></tr></table></figure></p>
<h2>方法二：使用/sys目录</h2>
<p>使用cd命令进入/sys/class/net/目录，然后ls查看目录下的文件，你会惊奇的发现里面有以网卡名命名的文件夹，</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@oishi net]<span class="variable">$ls</span></span><br><span class="line">eth0  lo</span><br></pre></td></tr></table></figure></p>
<p>这些文件夹便是你电脑中所有网卡，包括激活和未激活的（lo是本地回环网卡，并不是真实的网卡），cd进入任何一个目录（不是lo），然后，该网卡的所有信息便包含在里面(包括网卡的MAC地址信息)。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@oishi net]<span class="variable">$ls</span></span><br><span class="line">eth0  lo</span><br><span class="line">[yaxin@oishi net]<span class="variable">$cd</span> eth0/</span><br><span class="line">[yaxin@oishi eth0]<span class="variable">$ls</span></span><br><span class="line">addr_assign_<span class="built_in">type</span>  broadcast  dev_id   features  ifindex    mtu        queues      subsystem     uevent</span><br><span class="line">address           carrier    dormant  flags     iflink     operstate  speed       tx_queue_len</span><br><span class="line">addr_len          device     duplex   ifalias   link_mode  power      statistics  <span class="built_in">type</span></span><br><span class="line">[yaxin@oishi eth0]$</span><br></pre></td></tr></table></figure></p>
<p>然后使用cat命令查看一下address文件，显示的便是该网卡的MAC地址</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[yaxin@oishi eth0]<span class="variable">$cat</span> address </span><br><span class="line"><span class="number">00</span>:<span class="number">50</span>:<span class="number">56</span>:ac:<span class="number">57</span>:<span class="number">30</span></span><br><span class="line">[yaxin@oishi eth0]$</span><br></pre></td></tr></table></figure></p>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Linux/check-mac-address-under-linux.html#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Linux下文件的打包与解压缩命令]]></title>
      <link>http://yaxin-cn.github.io/Linux/file-compress-cmd-under-linux.html</link>
      <guid>http://yaxin-cn.github.io/Linux/file-compress-cmd-under-linux.html</guid>
      <pubDate>Sun, 16 Dec 2012 00:52:16 GMT</pubDate>
      <description>
      <![CDATA[<p>打包与解压缩命令属于Linux下最常用的命令之一。打包是指将一大堆文件或文件夹变成一个文件，压缩则是将一个大的文件通过一些压缩算法变成一个小文件。这跟Windows下使用WinRAR的打包不通，因为WinRAR打包后的文件也进行了压缩。下面就给出解压缩与打包的命令。</p>]]>
      </description>
      <content:encoded><![CDATA[<p>打包与解压缩命令属于Linux下最常用的命令之一。打包是指将一大堆文件或文件夹变成一个文件，压缩则是将一个大的文件通过一些压缩算法变成一个小文件。这跟Windows下使用WinRAR的打包不通，因为WinRAR打包后的文件也进行了压缩。下面就给出解压缩与打包的命令。</p>
<h2>一、基础篇</h2>
<p>我将本文分为两个部分：基础篇和提升篇。这部分是基础篇，主要介绍一些常用的打包和解压缩命令。学会使用这些命令，足够应付日常使用了。</p>
<h3>1. 打包、压缩命令</h3>
<p>首先给出命令：</p>
<blockquote>
<p>tar.gz格式:tar zcvf FileName.tar.gz DirName
tar.bz2格式:tar jcvf FileName.tar.bz2 DirName
zip格式:zip FileName.zip DirName</p>
</blockquote>
<p>一般来说，打包要伴随着压缩，所以我这里只是给出了打包压缩一体命令，并未将打包和压缩命令分开。上面命令中“DirName”为你要打包的文件夹，“FileName.**”为打包压缩后的文件名。在Linux下，常见的压缩包格式为tar.gz、tar.bz2和zip，所以这里不再给出rar格式的打包命令。</p>
<h3>2. 解压缩命令</h3>
<p>同样先给出命令：</p>
<blockquote>
<p>tar.gz格式:tar zxvf FileName.tar.gz
tar.bz2格式:tar jxvf FileName.tar.bz2
zip格式:unzip FileName.zip</p>
</blockquote>
<p>其中“FileName.*”为你需要解包的文件。</p>
<p>如果您只是想会解包打包，那么您可以就此停下来了，因为下面的都是上面命令的分析和补充。</p>
<h2>二、提升篇</h2>
<p>在Linux下打包和压缩命令是两个概念，各自的命令也不同，你可以只打包而不压缩或则只压缩而不打包。下面我们来看一下linux中的打包和压缩格式：</p>
<blockquote>
<p>.tar打包格式：tar程序打包的数据，并没有压缩过
.Z格式：compress程序压缩的文件
.gz压缩格式：gzip程序压缩的文件
.bz2压缩格式：bzip2程序压缩的文件
.tar.gz打包压缩：tar程序打包的文件，其中并且经过 gzip 的压缩
.tar.bz2打包压缩：tar程序打包的文件，其中并且经过 bzip2 的压缩</p>
</blockquote>
<p>在这些格式中，.Z（compress程序压缩的文件）已经几乎不见了，所以这里不再搭理。</p>
<h3>1.打包</h3>
<p>在Linux中，你会经常看到tar.gz或tar.bz2格式的源码包，其中的tar便是Linux下最常用的打包程序，使用tar程序打包过的文件一般称为tar包（格式为.tar）。下面我们就来看一下tar命令的基本使用方法：</p>
<p>首先给出tar命令的参数</p>
<blockquote>
<p>-c：(create)建立打包文件，搭配-v可察看打包过程中被打包的文件
-t：查看打包文件的内容含有哪些文件名
-x：解包或解压缩的功能，搭配-C（大写）可以在特定目录解开
-j：通过bzip2的进行压缩/解压缩，此时文件名正常情况下为*.tar.bz2
-z：通过gzip的进行压缩/解压缩，此时文件名正常情况下为*.tar.gz
-v：在压缩/解压缩的过程中，将正在处理的文件显示出来
-f：-f后面要立刻接要被处理的文件名，不要再加参数。也可以把-f单独写一个选项
-C：这个选项用在解压缩，后面跟目录。目的就是把文件解压缩到指定的目录
-p：保留数据的原本权限与属性，常用于备份(-c)
-P：保留绝对路径，也就是说允许备份数据中含有根目录存在之意
-r：向打包文件里面追加文件。例如用户已经打包好文件，又发现还有一个目录或是一些文件忘记打包了，这时可以使用该选项，将忘记的目录或文件追加到打包的文件中
–exclude=FILE：在压缩的过程中，不要将FILE打包
-u：更新文件。就是说，用新增的文件取代原备份文件，如果在备份文件中找不到要更新的文件，则把它追加到备份文件的最后
-N：比后面接的日期(yyyy/mm/dd)还要新的才会被打包进新建的文件中</p>
</blockquote>
<p>注意：-c, -t, -x参数不可同时出现。</p>
<p>下面来举几个例子：</p>
<p>tar -cf FileName.tar DirName：这条命令是将DirName的文件夹打成一个名为FileName.tar的包。-c是表示产生新的包，-f指定包的文件名；</p>
<p>tar -cf FileName.tar *.jpg：这条命令是将所有.jpg的文件打成一个名为FileName.tar的包；</p>
<p>tar -rf FileName.tar *.gif：这条命令是将所有.gif的文件增加到FileName.tar的包里面去。-r是表示增加文件的意思；</p>
<p>tar -uf FileName.tar logo.gif：这条命令是更新原来tar包FileName.tar中logo.gif文件，-u是表示更新文件的意思；</p>
<p>tar -tf FileName.tar：这条命令是列出FileName.tar包中所有文件，-t是列出文件的意思；</p>
<p>tar -xf FileName.tar：这条命令是解出FileName.tar包中所有文件，-x是解开的意思。</p>
<h3>2.压缩和解压</h3>
<p>①首先列出gzip程序命令压缩解压的参数：</p>
<blockquote>
<p>-c：将压缩的数据输出到屏幕上；
-d：解压缩 ；
-t：用来检验压缩文件有无错误；
-v：显示出原文件/压缩文件案的压缩比等信息；
-#：压缩等级，-1最快，但是压缩比最差。-9最慢，但是压缩比最好，预设是-6。</p>
</blockquote>
<p>当你使用gzip进行压缩时，在默认的状态下原来的文件被压缩成为。gz文件的同时源文件也就不再存在了。</p>
<p>下面给出使用gzip程序压缩解压的例子：</p>
<p>gzip FileName：此命令是压缩FileName文件；</p>
<p>gunzip FileName.gz：这条命令是解压缩FileName.gz文件;</p>
<p>gzip -d FileName.gz：此命令功能同上。</p>
<p>②接下来给出bizp2程序命令的压缩解压参数：</p>
<blockquote>
<p>-c：将压缩的过程产生的数据输出到屏幕上
-d：解压缩
-k：保留源文件，而不会删除原始的文件
-z：压缩
-v：可以显示出原文件/压缩文件的压缩比等信息
-#：与gzip同样的，都是在计算压缩比的参数，-9最佳，-1最快</p>
</blockquote>
<p>同样，在默认的状态下原来的文件被压缩成.bz2的文件，而源文件也会不存在了。但可以用-k参数保留源文件。</p>
<p>下面给出使用bzip2程序压缩解压的例子：</p>
<p>bzip2 -z FileName：这条命令是压缩FileName文件；</p>
<p>bzip2 -d FileName.bz2：解压FileName.bz2;</p>
<p>bunzip2 FileName.bz2：功能同上。</p>
<h3>3.打包和压缩解压命令合并</h3>
<p>如果将打包和压缩命令分开的话，会无故增加一步操作，从而带来很多不便，好在在执行打包（解包）命令的同时可以调用压缩（解压）的命令。</p>
<p>①tar调用gzip</p>
<p>-z：tar中使用此参数来调用gzip。
下面举例说明：</p>
<p>tar -zcvf FileName.tar.gz *.jpg：将所有的jpg格式的图片打包并压缩成FileName.tar.gz文件；</p>
<p>tar -zxvf FileName.tar.gz：将FileName.tar.gz文件解压。</p>
<p>②tar调用bzip2</p>
<p>-j：tar可以使用这个参数调用gzip。
下面举例说明：</p>
<p>tar -jcvf FileName.tar.bz2 *.jpg：将所有的jpg格式的图片打包并压缩成FileName.tar.bz2文件；</p>
<p>tar -jxvf FileName.tar.bz2：将FileName.tar.bz2文件解压。</p>
]]></content:encoded>
      <comments>http://yaxin-cn.github.io/Linux/file-compress-cmd-under-linux.html#disqus_comments</comments>
    </item>
    
  </channel>
</rss>